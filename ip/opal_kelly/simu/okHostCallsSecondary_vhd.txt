--------------------------------------------------------------------------
-- okHostCalls_vhd.txt
--
-- Description:
--    This file is a template for code to be pasted into a VHDL test fixture.
--    It is designed to mimic FrontPanel operations.  The functions and tasks 
--    below provide a pseudo translation between the FrontPanel operations 
--    and the hi_in, hi_out, and hi_inout signals.
--
--    Note that this file is designed to mimic a secondary FrontPanel
--    interface.
--
---------------------------------------------------------------------------
-- Copyright (c) 2020 Opal Kelly Incorporated
--------------------------------------------------------------------------


	--<<<<<<<<<<<<<<<<<<< USER TEST FIXTURE START CUT HERE >>>>>>>>>>>>>>>>>>>>-- 

	-----------------------------------------------------------------------
	-- User defined data for pipe and register procedures
	-----------------------------------------------------------------------
	variable BlockDelayStates : integer := 5;    -- REQUIRED: # of clocks between blocks of pipe data
	variable ReadyCheckDelay  : integer := 5;    -- REQUIRED: # of clocks before block transfer before
	                                             --    host interface checks for ready (0-255)
	variable PostReadyDelay   : integer := 5;    -- REQUIRED: # of clocks after ready is asserted and
	                                             --    check that the block transfer begins (0-255)
	variable pipeInSize       : integer := 1024; -- REQUIRED: byte (must be even) length of default
                                               --    PipeIn; Integer 0-2^32
	variable pipeOutSize      : integer := 1024; -- REQUIRED: byte (must be even) length of default
                                               --    PipeOut; Integer 0-2^32
	variable registerSetSize  : integer := 32;   -- Size of array for register set commands.
                                                                                            
	-----------------------------------------------------------------------
	-- Required data for procedures and functions
	-----------------------------------------------------------------------
	-- If you require multiple pipe arrays, you may create more arrays here
	-- duplicate the desired pipe procedures as required, change the names
	-- of the duplicated procedure to a unique identifiers, and alter the
	-- pipe array in that procedure to your newly generated arrays here.
	type PIPEIN_ARRAY is array (0 to pipeInSize - 1) of std_logic_vector(7 downto 0);
	variable pipeIn_s   : PIPEIN_ARRAY;

	type PIPEOUT_ARRAY is array (0 to pipeOutSize - 1) of std_logic_vector(7 downto 0);
	variable pipeOut_s  : PIPEOUT_ARRAY;

	type STD_ARRAY is array (0 to 31) of std_logic_vector(31 downto 0);
	variable WireIns_s    :  STD_ARRAY; -- 32x32 array storing WireIn values
	variable WireOuts_s   :  STD_ARRAY; -- 32x32 array storing WireOut values 
	variable Triggered_s  :  STD_ARRAY; -- 32x32 array storing IsTriggered values
	
	type REGISTER_ARRAY is array (0 to registerSetSize - 1) of std_logic_vector(31 downto 0);
	variable u32Address_s  : REGISTER_ARRAY;
	variable u32Data_s     : REGISTER_ARRAY;
	variable u32Count_s    : std_logic_vector(31 downto 0);
	variable ReadRegisterData_s    : std_logic_vector(31 downto 0);

	-----------------------------------------------------------------------
	-- FrontPanelResetSecondary
	-----------------------------------------------------------------------
	procedure FrontPanelResetSecondary is
		variable i : integer := 0;
		variable msg_line           : line;
	begin
			for i in 31 downto 0 loop
				WireIns_s(i) := (others => '0');
				WireOuts_s(i) := (others => '0');
				Triggered_s(i) := (others => '0');
			end loop;
			wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DReset;
			wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DNOP;
			wait until (hi_busy_s = '0');
	end procedure FrontPanelResetSecondary;

	-----------------------------------------------------------------------
	-- SetWireInValueSecondary
	-----------------------------------------------------------------------
	procedure SetWireInValueSecondary (
		ep   : in  std_logic_vector(7 downto 0);
		val  : in  std_logic_vector(31 downto 0);
		mask : in  std_logic_vector(31 downto 0)) is
		
		variable tmp_slv32 :     std_logic_vector(31 downto 0);
		variable tmpI      :     integer;
	begin
		tmpI := CONV_INTEGER(ep);
		tmp_slv32 := WireIns_s(tmpI) and (not mask);
		WireIns_s(tmpI) := (tmp_slv32 or (val and mask));
	end procedure SetWireInValueSecondary;

	-----------------------------------------------------------------------
	-- GetWireOutValueSecondary
	-----------------------------------------------------------------------
	impure function GetWireOutValueSecondary (
		ep : std_logic_vector) return std_logic_vector is
		
		variable tmp_slv32 : std_logic_vector(31 downto 0);
		variable tmpI      : integer;
	begin
		tmpI := CONV_INTEGER(ep);
		tmp_slv32 := WireOuts_s(tmpI - 16#20#);
		return (tmp_slv32);
	end GetWireOutValueSecondary;

	-----------------------------------------------------------------------
	-- IsTriggeredSecondary
	-----------------------------------------------------------------------
	impure function IsTriggeredSecondary (
		ep   : std_logic_vector;
		mask : std_logic_vector(31 downto 0)) return BOOLEAN is
		
		variable tmp_slv32   : std_logic_vector(31 downto 0);
		variable tmpI        : integer;
		variable msg_line    : line;
	begin
		tmpI := CONV_INTEGER(ep);
		tmp_slv32 := (Triggered_s(tmpI - 16#60#) and mask);

		if (tmp_slv32 >= 0) then
			if (tmp_slv32 = 0) then
				return FALSE;
			else
				return TRUE;
			end if;
		else
			write(msg_line, STRING'("***FRONTPANEL ERROR: IsTriggered mask 0x"));
			hwrite(msg_line, mask);
			write(msg_line, STRING'(" covers unused Triggers"));
			writeline(output, msg_line);
			return FALSE;        
		end if;     
	end IsTriggeredSecondary;

	-----------------------------------------------------------------------
	-- UpdateWireInsSecondary
	-----------------------------------------------------------------------
	procedure UpdateWireInsSecondary is
		variable i : integer := 0;
	begin
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DWires; 
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DUpdateWireIns; 
		wait until (rising_edge(hi_clk_s));
		hi_drive_s <= '1'; 
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DNOP; 
		for i in 0 to 31 loop
			hi_dataout_s <= WireIns_s(i);  wait until (rising_edge(hi_clk_s)); 
		end loop;
		wait until (hi_busy_s = '0');  
	end procedure UpdateWireInsSecondary;
   
	-----------------------------------------------------------------------
	-- UpdateWireOutsSecondary
	-----------------------------------------------------------------------
	procedure UpdateWireOutsSecondary is
		variable i : integer := 0;
	begin
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DWires; 
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DUpdateWireOuts; 
		wait until (rising_edge(hi_clk_s));
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DNOP; 
		wait until (rising_edge(hi_clk_s)); hi_drive_s <= '0'; 
		wait until (rising_edge(hi_clk_s)); wait until (rising_edge(hi_clk_s)); 
		for i in 0 to 31 loop
			wait until (rising_edge(hi_clk_s)); WireOuts_s(i) := hi_datain_s; 
		end loop;
		wait until (hi_busy_s = '0'); 
	end procedure UpdateWireOutsSecondary;

	-----------------------------------------------------------------------
	-- ActivateTriggerInSecondary
	-----------------------------------------------------------------------
	procedure ActivateTriggerInSecondary (
		ep  : in  std_logic_vector(7 downto 0);
		bit : in  integer) is 
		
		variable tmp_slv5 :     std_logic_vector(4 downto 0);
	begin
		tmp_slv5 := CONV_std_logic_vector(bit, 5);
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DTriggers;
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DActivateTriggerIn;
		wait until (rising_edge(hi_clk_s));
		hi_drive_s <= '1';
		hi_dataout_s <= (x"000000" & ep);
		wait until (rising_edge(hi_clk_s)); hi_dataout_s <= SHL(x"00000001", tmp_slv5); 
		hi_cmd_s <= DNOP;
		wait until (rising_edge(hi_clk_s)); hi_dataout_s <= x"00000000";
		wait until (hi_busy_s = '0');
	end procedure ActivateTriggerInSecondary;

	-----------------------------------------------------------------------
	-- UpdateTriggerOutsSecondary
	-----------------------------------------------------------------------
	procedure UpdateTriggerOutsSecondary is
	begin
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DTriggers;
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DUpdateTriggerOuts;
		wait until (rising_edge(hi_clk_s));
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DNOP;
		wait until (rising_edge(hi_clk_s)); hi_drive_s <= '0';
		wait until (rising_edge(hi_clk_s)); wait until (rising_edge(hi_clk_s));
		wait until (rising_edge(hi_clk_s));
		
		for i in 0 to (UPDATE_TO_READOUT_CLOCKS-1) loop
				wait until (rising_edge(hi_clk_s));  
		end loop;
		
		for i in 0 to 31 loop
			wait until (rising_edge(hi_clk_s)); Triggered_s(i) := hi_datain_s;
		end loop;
		wait until (hi_busy_s = '0');
	end procedure UpdateTriggerOutsSecondary;

	-----------------------------------------------------------------------
	-- WriteToPipeInSecondary
	-----------------------------------------------------------------------
	procedure WriteToPipeInSecondary (
		ep      : in  std_logic_vector(7 downto 0);
		length  : in  integer) is

		variable len, i, j, k, blockSize : integer;
		variable tmp_slv8                : std_logic_vector(7 downto 0);
		variable tmp_slv32               : std_logic_vector(31 downto 0);
	begin
		len := (length / 4); j := 0; k := 0; blockSize := 1024;
		tmp_slv8 := CONV_std_logic_vector(BlockDelayStates, 8);
		tmp_slv32 := CONV_std_logic_vector(len, 32);
		
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DPipes;
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DWriteToPipeIn;
		wait until (rising_edge(hi_clk_s)); 
		hi_drive_s <= '1';
		hi_dataout_s <= (x"0000" & tmp_slv8 & ep);
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DNOP;
		hi_dataout_s <= tmp_slv32;
		for i in 0 to len - 1 loop
			wait until (rising_edge(hi_clk_s));
			hi_dataout_s(7 downto 0) <= pipeIn_s(i*4);
			hi_dataout_s(15 downto 8) <= pipeIn_s((i*4)+1);
			hi_dataout_s(23 downto 16) <= pipeIn_s((i*4)+2);
			hi_dataout_s(31 downto 24) <= pipeIn_s((i*4)+3);
			j := j + 4;
			if (j = blockSize) then
				for k in 0 to BlockDelayStates - 1 loop
					wait until (rising_edge(hi_clk_s));
				end loop;
				j := 0;
			end if;
		end loop;
		wait until (hi_busy_s = '0');
	end procedure WriteToPipeInSecondary;

	-----------------------------------------------------------------------
	-- ReadFromPipeOutSecondary
	-----------------------------------------------------------------------
	procedure ReadFromPipeOutSecondary (
		ep     : in  std_logic_vector(7 downto 0);
		length : in  integer) is
		
		variable len, i, j, k, blockSize : integer;
		variable tmp_slv8                : std_logic_vector(7 downto 0);
		variable tmp_slv32               : std_logic_vector(31 downto 0);
	begin
		len := (length / 4); j := 0; blockSize := 1024;
		tmp_slv8 := CONV_std_logic_vector(BlockDelayStates, 8);
		tmp_slv32 := CONV_std_logic_vector(len, 32);
		
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DPipes;
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DReadFromPipeOut;
		wait until (rising_edge(hi_clk_s));
		hi_drive_s <= '1';
		hi_dataout_s <= (x"0000" & tmp_slv8 & ep);
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DNOP;
		hi_dataout_s <= tmp_slv32;
		wait until (rising_edge(hi_clk_s));
		hi_drive_s <= '0';
		for i in 0 to len - 1 loop
			wait until (rising_edge(hi_clk_s));
			pipeOut_s(i*4) := hi_datain_s(7 downto 0);
			pipeOut_s((i*4)+1) := hi_datain_s(15 downto 8);
			pipeOut_s((i*4)+2) := hi_datain_s(23 downto 16);
			pipeOut_s((i*4)+3) := hi_datain_s(31 downto 24);
			j := j + 4;
			if (j = blockSize) then
				for k in 0 to BlockDelayStates - 1 loop
					wait until (rising_edge(hi_clk_s));
				end loop;
				j := 0;
			end if;
		end loop;
		wait until (hi_busy_s = '0');
	end procedure ReadFromPipeOutSecondary;

	-----------------------------------------------------------------------
	-- WriteToBlockPipeInSecondary
	-----------------------------------------------------------------------
	procedure WriteToBlockPipeInSecondary (
		ep          : in std_logic_vector(7 downto 0);
		blockLength : in integer;
		length      : in integer) is
		
		variable len, i, j, k, blockSize, blockNum : integer;
		variable tmp_slv8                          : std_logic_vector(7 downto 0);
		variable tmp_slv16                         : std_logic_vector(15 downto 0);
		variable tmp_slv32                         : std_logic_vector(31 downto 0);
	begin
		len := (length/4); blockSize := (blockLength/4); j := 0; k := 0;
		blockNum := (len/blockSize);
		tmp_slv8 := CONV_std_logic_vector(BlockDelayStates, 8);
		tmp_slv16 := CONV_std_logic_vector(blockSize, 16);
		tmp_slv32 := CONV_std_logic_vector(len, 32);
		
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DPipes;
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DWriteToBlockPipeIn;
		wait until (rising_edge(hi_clk_s));
		hi_drive_s <= '1';
		hi_dataout_s <= (x"0000" & tmp_slv8 & ep);
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DNOP;
		hi_dataout_s <= tmp_slv32;
		wait until (rising_edge(hi_clk_s)); hi_dataout_s <= x"0000" & tmp_slv16;
		wait until (rising_edge(hi_clk_s));
		tmp_slv16 := (CONV_std_logic_vector(PostReadyDelay, 8) & CONV_std_logic_vector(ReadyCheckDelay, 8));
		hi_dataout_s <= x"0000" & tmp_slv16;
		for i in 1 to blockNum loop
			while (hi_busy_s = '1') loop wait until (rising_edge(hi_clk_s)); end loop;
			while (hi_busy_s = '0') loop wait until (rising_edge(hi_clk_s)); end loop;
			wait until (rising_edge(hi_clk_s)); wait until (rising_edge(hi_clk_s));
			for j in 1 to blockSize loop
				hi_dataout_s(7 downto 0) <= pipeIn_s(k);
				hi_dataout_s(15 downto 8) <= pipeIn_s(k+1);
				hi_dataout_s(23 downto 16) <= pipeIn_s(k+2);
				hi_dataout_s(31 downto 24) <= pipeIn_s(k+3);
				wait until (rising_edge(hi_clk_s)); k:=k+4;
			end loop;
			for j in 1 to BlockDelayStates loop 
				wait until (rising_edge(hi_clk_s)); 
			end loop;
		end loop;
		wait until (hi_busy_s = '0');
	end procedure WriteToBlockPipeInSecondary;

	-----------------------------------------------------------------------
	-- ReadFromBlockPipeOutSecondary
	-----------------------------------------------------------------------
	procedure ReadFromBlockPipeOutSecondary (
		ep          : in std_logic_vector(7 downto 0);
		blockLength : in integer;
		length      : in integer) is
		
		variable len, i, j, k, blockSize, blockNum : integer;
		variable tmp_slv8                          : std_logic_vector(7 downto 0);
		variable tmp_slv16                         : std_logic_vector(15 downto 0);
		variable tmp_slv32                         : std_logic_vector(31 downto 0);
	begin
		len := (length/4); blockSize := (blockLength/4); j := 0; k := 0;
		blockNum := (len/blockSize);
		tmp_slv8 := CONV_std_logic_vector(BlockDelayStates, 8);
		tmp_slv16 := CONV_std_logic_vector(blockSize, 16);
		tmp_slv32 := CONV_std_logic_vector(len, 32);
		
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DPipes;
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DReadFromBlockPipeOut;
		wait until (rising_edge(hi_clk_s));
		hi_drive_s <= '1';
		hi_dataout_s <= (x"0000" & tmp_slv8 & ep);
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DNOP;
		hi_dataout_s <= tmp_slv32;
		wait until (rising_edge(hi_clk_s)); hi_dataout_s <= x"0000" & tmp_slv16;
		wait until (rising_edge(hi_clk_s));
		tmp_slv16 := (CONV_std_logic_vector(PostReadyDelay, 8) & CONV_std_logic_vector(ReadyCheckDelay, 8));
		hi_dataout_s <= x"0000" & tmp_slv16;
		wait until (rising_edge(hi_clk_s)); hi_drive_s <= '0';
		for i in 1 to blockNum loop
			while (hi_busy_s = '1') loop wait until (rising_edge(hi_clk_s)); end loop;
			while (hi_busy_s = '0') loop wait until (rising_edge(hi_clk_s)); end loop;
			wait until (rising_edge(hi_clk_s)); wait until (rising_edge(hi_clk_s));
			for j in 1 to blockSize loop
				pipeOut_s(k) := hi_datain_s(7 downto 0); 
				pipeOut_s(k+1) := hi_datain_s(15 downto 8);
				pipeOut_s(k+2) := hi_datain_s(23 downto 16);
				pipeOut_s(k+3) := hi_datain_s(31 downto 24);
				wait until (rising_edge(hi_clk_s)); k:=k+4;
			end loop;
			for j in 1 to BlockDelayStates loop wait until (rising_edge(hi_clk_s)); end loop;
		end loop;
		wait until (hi_busy_s = '0');
	end procedure ReadFromBlockPipeOutSecondary;
	
	-----------------------------------------------------------------------
	-- WriteRegisterSecondary
	-----------------------------------------------------------------------
	procedure WriteRegisterSecondary (
		address  : in  std_logic_vector(31 downto 0);
		data     : in  std_logic_vector(31 downto 0)) is
	begin
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DRegisters;
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DWriteRegister;
		wait until (rising_edge(hi_clk_s));
		hi_drive_s <= '1';
		hi_cmd_s <= DNOP;
		wait until (rising_edge(hi_clk_s)); hi_dataout_s <= address; 
		wait until (rising_edge(hi_clk_s)); hi_dataout_s <= data;
		wait until (hi_busy_s = '0'); hi_drive_s <= '0';  
	end procedure WriteRegisterSecondary;
	
	-----------------------------------------------------------------------
	-- ReadRegisterSecondary
	-----------------------------------------------------------------------
	procedure ReadRegisterSecondary (
		address  : in  std_logic_vector(31 downto 0);
		data     : out std_logic_vector(31 downto 0)) is
	begin
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DRegisters;
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DReadRegister;
		wait until (rising_edge(hi_clk_s));
		hi_drive_s <= '1';
		hi_cmd_s <= DNOP;
		wait until (rising_edge(hi_clk_s)); hi_dataout_s <= address; 
		wait until (rising_edge(hi_clk_s)); hi_drive_s <= '0';
		wait until (rising_edge(hi_clk_s));
		wait until (rising_edge(hi_clk_s)); data := hi_datain_s;
		wait until (hi_busy_s = '0');
	end procedure ReadRegisterSecondary;
	
	
	-----------------------------------------------------------------------
	-- WriteRegisterSetSecondary
	-----------------------------------------------------------------------
	procedure WriteRegisterSetSecondary is
		variable i             :     integer;
		variable u32Count_int  :     integer;
	begin
	  u32Count_int := CONV_INTEGER(u32Count_s);
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DRegisters;
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DWriteRegisterSet;
		wait until (rising_edge(hi_clk_s));
		hi_drive_s <= '1';
		hi_cmd_s <= DNOP;
		wait until (rising_edge(hi_clk_s)); hi_dataout_s <= u32Count_s; 
		for i in 1 to u32Count_int loop
			wait until (rising_edge(hi_clk_s)); hi_dataout_s <= u32Address_s(i-1);
			wait until (rising_edge(hi_clk_s)); hi_dataout_s <= u32Data_s(i-1);
			wait until (rising_edge(hi_clk_s)); wait until (rising_edge(hi_clk_s));
		end loop;
		wait until (hi_busy_s = '0'); hi_drive_s <= '0';  
	end procedure WriteRegisterSetSecondary;
	
	-----------------------------------------------------------------------
	-- ReadRegisterSetSecondary
	-----------------------------------------------------------------------
	procedure ReadRegisterSetSecondary is
		variable i             :     integer;
		variable u32Count_int  :     integer;
	begin
	  u32Count_int := CONV_INTEGER(u32Count_s);
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DRegisters;
		wait until (rising_edge(hi_clk_s)); hi_cmd_s <= DReadRegisterSet;
		wait until (rising_edge(hi_clk_s));
		hi_drive_s <= '1';
		hi_cmd_s <= DNOP;
		wait until (rising_edge(hi_clk_s)); hi_dataout_s <= u32Count_s; 
		for i in 1 to u32Count_int loop
			wait until (rising_edge(hi_clk_s)); hi_dataout_s <= u32Address_s(i-1);
			wait until (rising_edge(hi_clk_s)); hi_drive_s <= '0'; 
			wait until (rising_edge(hi_clk_s)); 
			wait until (rising_edge(hi_clk_s)); u32Data_s(i-1) := hi_datain_s;
			hi_drive_s <= '1';
		end loop;
		wait until (hi_busy_s = '0');
	end procedure ReadRegisterSetSecondary;
	
	-----------------------------------------------------------------------
	-- Available User Task and Function Calls:
	--    FrontPanelResetSecondary;              -- Always start routine with FrontPanelReset;
	--    SetWireInValueSecondary(ep, val, mask);
	--    UpdateWireInsSecondary;
	--    UpdateWireOutsSecondary;
	--    GetWireOutValueSecondary(ep);          -- returns a 16 bit SLV
	--    ActivateTriggerInSecondary(ep, bit);   -- bit is an integer 0-15
	--    UpdateTriggerOutsSecondary;
	--    IsTriggeredSecondary(ep, mask);        -- returns a BOOLEAN
	--    WriteToPipeInSecondary(ep, length);    -- pass pipeIn_s array data; length is integer
	--    ReadFromPipeOutSecondary(ep, length);  -- pass data to pipeOut_s array; length is integer
	--    WriteToBlockPipeInSecondary(ep, blockSize, length);   -- pass pipeIn_s array data; blockSize and length are integers
	--    ReadFromBlockPipeOutSecondary(ep, blockSize, length); -- pass data to pipeOut_s array; blockSize and length are integers
	--    WriteRegisterSecondary(addr, data);  
	--    ReadRegisterSecondary(addr, data);
	--    WriteRegisterSetSecondary();  
	--    ReadRegisterSetSecondary();
	--
	-- *  Pipes operate by passing arrays of data back and forth to the user's
	--    design.  If you need multiple arrays, you can create a new procedure
	--    above and connect it to a differnet array.  More information is
	--    available in Opal Kelly documentation and online support tutorial.
	-----------------------------------------------------------------------
--<<<<<<<<<<<<<<<<<<< USER TEST FIXTURE END CUT HERE >>>>>>>>>>>>>>>>>>>>>>--
