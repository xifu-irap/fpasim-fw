// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                    CDCE72010.dscript
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference
// -------------------------------------------------------------------------------------------------------------
//    @details
//
//    This javscript generates spi commands in order to initialize the cdce72010 registers.
//
//    Note:
//       . Tested with javascript
//
// -------------------------------------------------------------------------------------------------------------

// import libraries
include("./fpasim/display.dscript");
include("./fpasim/fpasim_address.dscript");


// const AMC_ADDR = {};
// AMC_ADDR['reg0'] = 0x00;
// AMC_ADDR['reg1'] = 0x01;
// AMC_ADDR['reg2'] = 0x02;
// AMC_ADDR['reg3'] = 0x03;
// AMC_ADDR['reg4'] = 0x04;
// AMC_ADDR['reg5'] = 0x05;
// AMC_ADDR['reg6'] = 0x06;
// AMC_ADDR['reg7'] = 0x07;
// AMC_ADDR['reg8'] = 0x08;
// AMC_ADDR['reg9'] = 0x09;
// AMC_ADDR['reg10'] = 0x0A;
// AMC_ADDR['reg11'] = 0x0B;
// AMC_ADDR['reg12'] = 0x0C;

/**
  This function reverse the bit orders.
  width_p  | value_p            | result            |
  ---------|--------------------|-------------------|
  4        | 1 ("0001")         | 8 ("1000")        |
  4        | 3 ("0011")         | 12 ("1100")       |
  4        | 3 ("0111")         | 14 ("1110")       |
  5        | 1 ("00001")        | 16 ("10000")      |

  * @param {number} value_p - value where to reverse bit
  * @param {number} width_p - width of the input value (expressed in bits)
  * @return {number} value with the bit reverse

*/
function reverse_bit_order(value_p,width_p)
{
  res = 0;
  bit_max_pos = width_p - 1;
    for (i = 0; i<width_p;i++)
  {
        // get bit value (LSB first)
        value = (value_p >> i) & 0x1;
        res = res + value*Math.pow(2,bit_max_pos - i);
  }

    return res;

}


    /*
    FPGA specifics:
     Initialize the spi links
    */    
    function amc_init_device()
    {
        //---------------------------------------------------------------------
        //-- write in the SPI_CTRL register 
        //---------------------------------------------------------------------

        // reset the spi links
        // rst = 1;
        // en = 0;
        // data = (rst << 1) + en;
        // sendToFPA_debugSetWireIn(0x12,data);

        //---------------------------------------------------------------------
        //-- write in the SPI_CTRL register 
        //---------------------------------------------------------------------
        
        // en the spi links
        rst = 0;
        en = 1;
        data = (rst << 1) + en;
        addr = FPASIM_ADDR_WIREIN['SPI_CTRL'];
        sendToFPA_debugSetWireIn(addr ,data);
    }

    /**
    * FPGA specifics: 
        Build the expected spi command
        Build the expected fpga register accesses
    */
    function amc_write_command(addr_p,data_p,page_p)
      {

        //---------------------------------------------------------------------
        // write in the SPI_CONF register
        //---------------------------------------------------------------------
        mode = 1; // 0: rd, 1: wr
        spi_id = 3; // 0: cdce,1: adc, 2: dac, 3: amc
        spi_dac_tx_enable = 0;
        data = (spi_dac_tx_enable << 8) + (spi_id << 4) + mode;
        addr = FPASIM_ADDR_WIREIN['SPI_CONF'];
        sendToFPA_debugSetWireIn(addr,data);

        //---------------------------------------------------------------------
        // build the SPI commands
        //    (see amc7823 datasheet) 
        //---------------------------------------------------------------------
        mode = 0; // 0:wr, 1:rd
        page = page_p // 0: page0, 1: page1
        start_addr = addr_p // start address: 5 bits
        end_addr = 0x00

        spi_cmd = (mode << 15) + (page << 12) + (start_addr<<6) + (end_addr);
        // MSB send first
        //  spi_cmd[15:0]
        //  spi_data[15:0]
        spi_data = (spi_cmd << 16) + data_p;
        addr = FPASIM_ADDR_WIREIN['SPI_WR_DATA'];
        //---------------------------------------------------------------------
        // write in the SPI_WR_DATA register
        //---------------------------------------------------------------------
        sendToFPA_debugSetWireIn(addr,spi_data);

        //---------------------------------------------------------------------
        // write in the TRIG register
        //  => activate the spi_valid bit
        //---------------------------------------------------------------------
        addr = FPASIM_ADDR_TRIGIN['TRIG'];
        pos =  FPASIM_POS_TRIGIN['spi_valid'];
        sendToFPA_debugSetTriggerIn(addr,pos);
        waitMs(100);

      }

      function amc_read_command(addr_p,page_p)
      {

        //---------------------------------------------------------------------
        // write in the SPI_CONF register
        //---------------------------------------------------------------------
        mode = 0; // 0: rd, 1: wr
        spi_id = 3; // 0: cdce,1: adc, 2: dac, 3: amc
        spi_dac_tx_enable = 0;
        data = (spi_dac_tx_enable << 8) + (spi_id << 4) + mode;
        addr = FPASIM_ADDR_WIREIN['SPI_CONF'];
        sendToFPA_debugSetWireIn(addr,data);

        //---------------------------------------------------------------------
        // build the SPI commands
        //    (see amc7823 datasheet) 
        //---------------------------------------------------------------------
        mode = 1; // 0:wr, 1:rd
        page = page_p // 0: page0, 1: page1
        start_addr = addr_p // start address: 5 bits
        end_addr = 0x00

        spi_cmd = (mode << 15) + (page << 12) + (start_addr<<6) + (end_addr);
        // MSB send first
        //  spi_cmd[15:0]
        //  spi_data[15:0]
        spi_data = (spi_cmd << 16) + 0x0000;
        addr = FPASIM_ADDR_WIREIN['SPI_WR_DATA'];
        //---------------------------------------------------------------------
        // write in the SPI_WR_DATA register
        //---------------------------------------------------------------------
        sendToFPA_debugSetWireIn(addr,spi_data);

        //---------------------------------------------------------------------
        // write in the TRIG register
        //  => activate the spi_valid bit
        //---------------------------------------------------------------------
        addr = FPASIM_ADDR_TRIGIN['TRIG'];
        pos =  FPASIM_POS_TRIGIN['spi_valid'];
        sendToFPA_debugSetTriggerIn(addr,pos);
        waitMs(100);
        //---------------------------------------------------------------------
        // Read wire out registers
        //---------------------------------------------------------------------
        getLatestValue("FPA_WireOutValues");

        return FPA_WireOutValues[21];

      }

    /**
     * #############################################################
     *  set the amc_set_gpio register
     * ##############################################################
     *  [11:08]: R/W: iomod_p[3:0]
     *  [05:00]: R/W: iost_p[5:0]
      */
    function amc_set_gpio(iomod_p,iost_p)
    {


        cmt = 'amc_set_gpio'
        value1 = (parseInt('1111',2) << 12) + (parseInt('11',2) << 6)
        value0 = (iomod_p << 8) + iost_p

        value = value1 +  value0;
        page = 0

        amc_write_command(addr_p=0x0A,data_p=value,page_p=page)
    }

    /**
     * ##############################################################
     *  set the dac(s) register
     * ##############################################################
     *  [11:0]: R/W: dac[11:0]
     *  dac_id_p: (0 to 7)
    */
    function amc_set_dac(dac_p,dac_id_p)
    {


        cmt = 'amc_set_dac';
        value0 = dac_p;

        value = value0;
        page = 1;

        switch(dac_id_p) 
        {
          case 0:
            addr = 0x00;
            break;
          case 1:
            addr = 0x01;
            break;
        case 2:
            addr = 0x02;
            break;
        case 3:
            addr = 0x03;
            break;
        case 4:
            addr = 0x04;
            break;
        case 5:
            addr = 0x05;
            break;
        case 6:
            addr = 0x06;
            break;
        default: // dac_id_p == 6
            addr = 0x07;
            break;
        } 

        amc_write_command(addr_p=addr,data_p=value,page_p=page);
    }


    /**
    * ##############################################################
    *  set the dac_load register
    * ##############################################################
    *  RW
    */
    function amc_set_dac_load()
    {

      
        cmt = 'amc_set_dac_load'
        value0 = 0xBB00;

        value = value0;
        page = 1
        addr = 0x08;

        amc_write_command(addr_p=addr,data_p=value,page_p=page)
    }

    /**
    * ##############################################################
    *  set the dac_conf(s) register
    * ##############################################################
    *  [15:8]: R/W: slda_p[7:0]
    *  [7:0]: R/W: gdac_p[7:0]
    */
    function amc_set_dac_conf(slda_p,gdac_p)
    {

        cmt = 'amc_set_dac_conf'
        value0 = (slda_p << 8) + gdac_p

        value = value0
        page = 1
        addr = 0x09;

        amc_write_command(addr_p=addr,data_p=value,page_p=page)

    }
    /**
    * ##############################################################
    *  set the amc_set_amc_status_conf register
    * ##############################################################
    *  [14]: R/W: rstc_p[0]
    *  [13]: R/W: davf_p[0]
    *  [7]: R/W: sref_p[0]
    *  [6]: R/W: gref_p[0]
    *  [5]: R/W: ecnvt_p[0]
    */
    function amc_set_amc_status_conf(rstc_p,davf_p,sref_p,gref_p,ecnvt_p)
    {


        cmt = 'amc_set_amc_status_conf'
        value1 = (rstc_p << 14) + (davf_p << 13)
        value0 = (sref_p << 7) + (gref_p << 6) + (ecnvt_p << 5) 

        value = value1 + value0
        page = 1
        addr = 0x0A;

        amc_write_command(addr_p=addr,data_p=value,page_p=page)
    }

    /**
    * ##############################################################
    *  set the amc_set_adc_ctrl register
    * ##############################################################
    *  [15]: R/W: cmode_p[0]
    *  [11:8]: R/W: sa_p[3:0]: The channel address of the first analog input to be converted (
    *  [7:4]: R/W: ea_p[3:0]:  The channel address of the last analog input to be converted
    */
    function amc_set_adc_ctrl(cmode_p,sa_p,ea_p)
    {

        cmt = 'amc_set_adc_ctrl'
        value1 = (cmode_p << 15) + (sa_p << 8)
        value0 = (ea_p << 4)

        value = value1 + value0
        page = 1
        addr = 0x0B;

        amc_write_command(addr_p=addr,data_p=value,page_p=page)
    }

    /**
    * ##############################################################
    *  set the amc_set_reset register
    * ##############################################################
    */
    function amc_set_reset()
    {


        cmt = 'amc_set_reset'
        value0 = 0xBB30

        value = value0
        page = 1
        addr = 0x0C;

        amc_write_command(addr_p=addr,data_p=value,page_p=page)
    }

    /*
    * ##############################################################
    *  set the amc_set_power_down register
    * ##############################################################
    *  [15]: R/W: padc_p[0]
    *  [14:7]: R/W: pdac_p[7:0]
    *  [6]: R/W: pts_p[0]
    *  [5]: R/W: prefb_p[0]
    */
    function amc_set_power_down( padc_p, pdac_p, pts_p, prefb_p)
    {


        cmt = 'amc_set_power_down'
        value1 = (padc_p << 15) + (pdac_p << 7)
        value0 = (pts_p << 6) + (prefb_p << 5)

        value = value1 + value0
        page = 1
        addr = 0x0D;

        amc_write_command(addr_p=addr,data_p=value,page_p=page)
    }

    /*
    * ##############################################################
    *  set the amc_set_threshold_hi register
    * ##############################################################
    *  [11:0]: R/W: threshold_p[11:0]
    *  threshold_id_p (0 to 3)
    */
    function amc_set_threshold_hi(threshold_p,threshold_id_p)
    {


        cmt = 'amc_set_threshold_hi'
        value0 = threshold_p

        value =  value0
        page = 1
        switch(threshold_id_p)
        {

        case 0:
            addr = 0x0E;
            break;
        case 1:
            addr = 0x10;
            break;
        case  2:
            addr = 0x12;
            break;
        default: // threshold_id = 3
            addr = 0x14;
            break;
        }

        amc_write_command(addr_p=addr,data_p=value,page_p=page)
    }

    /**
    * ##############################################################
    *  set the amc_set_threshold_lo register
    * ##############################################################
    *  [11:0]: R/W: threshold_p[11:0]
    *  threshold_id_p (0 to 3)
    */
    function amc_set_threshold_lo(threshold_p,threshold_id_p)
    {


        cmt = 'amc_set_threshold_lo'
        value0 = threshold_p

        value =  value0
        page = 1
        switch(threshold_id_p)
        {

        case 0:
            addr = 0x0F;
            break;
        case 1:
            addr = 0x11;
            break;
        case  2:
            addr = 0x13;
            break;
        default: // threshold_id = 3
            addr = 0x15;
            break;
        }

        amc_write_command(addr_p=addr,data_p=value,page_p=page)
    }

    /**
     * #############################################################
     *  set the amc_get_gpio register
     * ##############################################################
     *  [11:08]: R/W: iomod_p[3:0]
     *  [05:00]: R/W: iost_p[5:0]
      */
    function amc_get_gpio(level_p,mode_p,verbosity_p)
    {

        // default function parameter values
    if (typeof(level_p)==='undefined') level_p = 0;
    if (typeof(mode_p)==='undefined') mode_p = 0;
    if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

    level0 = level_p;
    level1 = level_p + 1;


    // get the wireout values
    getLatestValue("FPA_WireOutValues");

        cmt = 'amc_get_gpio'
        value = amc_read_command(addr_p=0x0A,page_p=page)

        iomod_p = ((value >> 8) & 0xF);
        iost_p = ((value >> 0) & 0x1F);


        msg_field = [
                'data : 0x'+convert_int_to_str_hex(value_p=value,width_p=32),
                'iomod_p: 0x'+convert_int_to_str_hex(value_p=iomod_p,width_p=4),
                'iost_p: 0x'+convert_int_to_str_hex(value_p=iost_p,width_p=6)
                ];
      /*
        print field values
    */
      if (verbosity_p > 0)
      {
        msg = "DATA : " + data.toString(16);
        display(msg_p=msg, level_p=level0, mode_p=mode_p);
        display(msg_p=msg_field, level_p=level0, mode_p=mode_p);
      }
      return value;
    }


    /**
     * ##############################################################
     *  set the amc_get_adc register
     * ##############################################################
     *  dac_id_p: (0 to 7)
    */
    function amc_get_adc(adc_id_p,level_p,mode_p,verbosity_p)
    {

		// default function parameter values
    if (typeof(level_p)==='undefined') level_p = 0;
    if (typeof(mode_p)==='undefined') mode_p = 0;
    if (typeof(verbosity_p)==='undefined') verbosity_p = 0;
        cmt = 'amc_get_adc';

        page = 0;

        switch(adc_id_p) 
        {
          case 0:
            addr = 0x00;
            break;
          case 1:
            addr = 0x01;
            break;
        case 2:
            addr = 0x02;
            break;
        case 3:
            addr = 0x03;
            break;
        case 4:
            addr = 0x04;
            break;
        case 5:
            addr = 0x05;
            break;
        case 6:
            addr = 0x06;
            break;
        case 7:
            addr = 0x07;
            break;
        default: // adc_id_p = 8
            addr = 0x08;
            break;
        } 

        value = amc_read_command(addr_p=addr,page_p=page);
        ich_p = (value >> 12) & 0xF;
        adc_p = (value >> 0) & 0xFFF;

        msg_field = [
                'data : 0x'+convert_int_to_str_hex(value_p=value,width_p=32),
                'ich_p: 0x'+convert_int_to_str_hex(value_p=ich_p,width_p=4),
                'adc_p: 0x'+convert_int_to_str_hex(value_p=adc_p,width_p=12)
                ];
				
				 /*
        print field values
    */
      if (verbosity_p > 0)
      {
        msg = "DATA : " + data.toString(16);
        display(msg_p=msg, level_p=level0, mode_p=mode_p);
        display(msg_p=msg_field, level_p=level0, mode_p=mode_p);
      }
      return value;
    }



//###############################################################
// Configure the CDCE72010 Device
//###############################################################
function AMC7823_configure(verbosity_p)
    {

	if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

    amc_init_device();

   /**
     * #############################################################
     *  set the amc_set_gpio register
     * ##############################################################
     *  [11:08]: R/W: iomod_p[3:0]
     *  [05:00]: R/W: iost_p[5:0]
      */
    iomod = parseInt('1111',2);
    iost = parseInt('111111',2);
    amc_set_gpio(iomod_p=iomod,iost_p=iost);

    /**
    * ##############################################################
    *  set the amc_set_amc_status_conf register
    * ##############################################################
    *  [14]: R/W: rstc_p[0]
    *  [13]: R/W: davf_p[0]
    *  [7]: R/W: sref_p[0]
    *  [6]: R/W: gref_p[0]
    *  [5]: R/W: ecnvt_p[0]
    */
    rstc = 0;
    davf = 0;
    sref = 0;
    gref = 0;
    ecnvt = 0;
    amc_set_amc_status_conf(rstc_p = rstc,davf_p = davf,sref_p=sref,gref_p=gref,ecnvt_p=ecnvt);

    /**
    * ##############################################################
    *  set the amc_set_adc_ctrl register
    * ##############################################################
    *  [15]: R/W: cmode_p[0]
    *  [11:8]: R/W: sa_p[3:0]: The channel address of the first analog input to be converted (
    *  [7:4]: R/W: ea_p[3:0]:  The channel address of the last analog input to be converted
    */
    cmode = 1;// 0: direct mode, 1: auto-mode
    sa = parseInt('0000',2); // adc0
    ea = parseInt('1000',2); // adc8
    amc_set_adc_ctrl(cmode_p = cmode,sa_p=sa,ea_p = ea);

    /*
    * ##############################################################
    *  set the amc_set_power_down register
    * ##############################################################
    *  [15]: R/W: padc_p[0]
    *  [14:7]: R/W: pdac_p[7:0]
    *  [6]: R/W: pts_p[0]
    *  [5]: R/W: prefb_p[0]
    */
    padc = 1;// 0: adc is power down, 1: adc is in normal mode
    pdac = parseInt('0000_0000',2);//0: DACi is power down,1 + (prefb = 1) = DAC is normal mode
    pts = 0;//0: Precision current source is in power-down mode and the current output is zero, 1:Precision current source is in normal operating mode
    prefb = 0;//0: Reference buffer amplifier is in power-down mode, 1:Reference buffer amplifier is powered on
    amc_set_power_down(padc_p=padc, pdac_p=pdac, pts_p=pts, prefb_p=prefb);

    /*
    * ##############################################################
    *  set the amc_set_threshold_hi register
    * ##############################################################
    *  [11:0]: R/W: threshold_p[11:0]
    *  threshold_id_p (0 to 3)
    */
    threshold = 0x0B16;
    threshold_id = 0;
    amc_set_threshold_hi(threshold_p=threshold,threshold_id_p=threshold_id);

     /**
    * ##############################################################
    *  set the amc_set_threshold_lo register
    * ##############################################################
    *  [11:0]: R/W: threshold_p[11:0]
    *  threshold_id_p (0 to 3)
    */
    threshold = 0x0A08;
    threshold_id = 0;
    amc_set_threshold_lo(threshold_p=threshold,threshold_id_p=threshold_id);

    /*
    * ##############################################################
    *  set the amc_set_threshold_hi register
    * ##############################################################
    *  [11:0]: R/W: threshold_p[11:0]
    *  threshold_id_p (0 to 3)
    */
    threshold = 0x0B16;
    threshold_id = 1;
    amc_set_threshold_hi(threshold_p=threshold,threshold_id_p=threshold_id);

     /**
    * ##############################################################
    *  set the amc_set_threshold_lo register
    * ##############################################################
    *  [11:0]: R/W: threshold_p[11:0]
    *  threshold_id_p (0 to 3)
    */
    threshold = 0x0A08;
    threshold_id = 1;
    amc_set_threshold_lo(threshold_p=threshold,threshold_id_p=threshold_id);

    /*
    * ##############################################################
    *  set the amc_set_threshold_hi register
    * ##############################################################
    *  [11:0]: R/W: threshold_p[11:0]
    *  threshold_id_p (0 to 3)
    */
    threshold = 0x0C18;
    threshold_id = 2;
    amc_set_threshold_hi(threshold_p=threshold,threshold_id_p=threshold_id);

     /**
    * ##############################################################
    *  set the amc_set_threshold_lo register
    * ##############################################################
    *  [11:0]: R/W: threshold_p[11:0]
    *  threshold_id_p (0 to 3)
    */
    threshold = 0x0AF1;
    threshold_id = 2;
    amc_set_threshold_lo(threshold_p=threshold,threshold_id_p=threshold_id);

    /*
    * ##############################################################
    *  set the amc_set_threshold_hi register
    * ##############################################################
    *  [11:0]: R/W: threshold_p[11:0]
    *  threshold_id_p (0 to 3)
    */
    threshold = 0x0C18;
    threshold_id = 3;
    amc_set_threshold_hi(threshold_p=threshold,threshold_id_p=threshold_id);

     /**
    * ##############################################################
    *  set the amc_set_threshold_lo register
    * ##############################################################
    *  [11:0]: R/W: threshold_p[11:0]
    *  threshold_id_p (0 to 3)
    */
    threshold = 0x0AF1;
    threshold_id = 3;
    amc_set_threshold_lo(threshold_p=threshold,threshold_id_p=threshold_id);
    





    }