// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                   ADS62P49.py
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference
// -------------------------------------------------------------------------------------------------------------
//    @details
//
//   This javscript generates spi commands in order to initialize the ads62P49 (ADCs) registers.
//
//   Note:
//      . Tested with javascript
//
// -------------------------------------------------------------------------------------------------------------

// import libraries
include("./fpasim/display.dscript");
include("./fpasim/fpasim_address.dscript");

// define ADC device addresses
const ADC_ADDR = {};
ADC_ADDR['reg0'] = 0x00;
ADC_ADDR['reg1'] = 0x20;
ADC_ADDR['reg2'] = 0x3F;
ADC_ADDR['reg3'] = 0x40;
ADC_ADDR['reg4'] = 0x41;
ADC_ADDR['reg5'] = 0x44;
ADC_ADDR['reg6'] = 0x50;
ADC_ADDR['reg7'] = 0x51;
ADC_ADDR['reg8'] = 0x52;
ADC_ADDR['reg9'] = 0x53;
ADC_ADDR['reg10'] = 0x55;
ADC_ADDR['reg11'] = 0x57;
ADC_ADDR['reg12'] = 0x62;
ADC_ADDR['reg13'] = 0x63;
ADC_ADDR['reg14'] = 0x66;
ADC_ADDR['reg15'] = 0x68;
ADC_ADDR['reg16'] = 0x6A;
ADC_ADDR['reg17'] = 0x75;
ADC_ADDR['reg18'] = 0x76;

     /**
    * FPGA specifics: Initialize the spi links
    * @param {number} level_p - level of indentation at the beginning
    * @param {number} mode_p - define the print output
    * @param {number} verbosity_p - level of verbosity
    */    
    function adc_init_device(level_p,mode_p,verbosity_p)
    {
        // default function parameter values
        if (typeof(level_p)==='undefined') level_p = 0;
        if (typeof(mode_p)==='undefined') mode_p = 0;
        if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

        //---------------------------------------------------------------------
        //-- write in the SPI_CTRL register 
        //---------------------------------------------------------------------

        // reset the spi links
        // rst = 1;
        // en = 0;
        // data = (rst << 1) + en;
        // sendToFPA_debugSetWireIn(0x12,data);

        //---------------------------------------------------------------------
        //-- write in the SPI_CTRL register 
        //---------------------------------------------------------------------
        
        // en the spi links
        rst = 0;
        en = 1;
        data = (rst << 1) + en;
        addr = FPASIM_ADDR_WIREIN['SPI_CTRL'];
        sendToFPA_debugSetWireIn(addr ,data);
    }

    /**
    * FPGA specifics: 
        Build the expected spi command
        Build the expected fpga register accesses
    */
    function adc_write_command(addr_p,data_p)
      {

        //---------------------------------------------------------------------
        // write in the SPI_CONF register
        //---------------------------------------------------------------------
        mode = 1; // 0: rd, 1: wr
        spi_id = 1; // 0: cdce,1: adc, 2: dac, 3: amc
        spi_dac_tx_enable = 0;
        data = (spi_dac_tx_enable << 8) + (spi_id << 4) + mode;
        addr = FPASIM_ADDR_WIREIN['SPI_CONF'];
        sendToFPA_debugSetWireIn(addr,data);

        //---------------------------------------------------------------------
        // build the SPI commands
        //   (see the ads62P49 datasheet)
        //---------------------------------------------------------------------

        spi_cmd = (addr_p << 8) + data_p;
        addr = FPASIM_ADDR_WIREIN['SPI_WR_DATA'];
        //---------------------------------------------------------------------
        // write in the SPI_WR_DATA register
        //---------------------------------------------------------------------
        sendToFPA_debugSetWireIn(addr,spi_cmd);

        //---------------------------------------------------------------------
        // write in the TRIG register
        //  => activate the spi_valid bit
        //---------------------------------------------------------------------
        addr = FPASIM_ADDR_TRIGIN['TRIG'];
        pos =  FPASIM_POS_TRIGIN['spi_valid'];
        sendToFPA_debugSetTriggerIn(addr,pos);
        waitMs(100);

      }

      function adc_read_command(addr_p)
      {

        //---------------------------------------------------------------------
        // write in the SPI_CONF register
        //---------------------------------------------------------------------
        mode = 0; // 0: rd, 1: wr
        spi_id = 1; // 0: cdce,1: adc, 2: dac, 3: amc
        spi_dac_tx_enable = 0;
        data = (spi_dac_tx_enable << 8) + (spi_id << 4) + mode;
        addr = FPASIM_ADDR_WIREIN['SPI_CONF'];
        sendToFPA_debugSetWireIn(addr,data);

        //---------------------------------------------------------------------
        // build the SPI commands
        //   (see the ads62P49 datasheet)
        //---------------------------------------------------------------------
        data = 0x0;
        spi_cmd = (addr_p << 8) + data;
        //---------------------------------------------------------------------
        // write in the SPI_WR_DATA register
        //---------------------------------------------------------------------
        addr = FPASIM_ADDR_WIREIN['SPI_WR_DATA'];
        sendToFPA_debugSetWireIn(addr,spi_cmd);

        //---------------------------------------------------------------------
        // write in the TRIG register
        //  => activate the spi_valid bit
        //---------------------------------------------------------------------
        addr = FPASIM_ADDR_TRIGIN['TRIG'];
        pos =  FPASIM_POS_TRIGIN['spi_valid'];
        sendToFPA_debugSetTriggerIn(addr,pos);
        waitMs(100);

        //---------------------------------------------------------------------
        // Read wire out registers
        //---------------------------------------------------------------------
        getLatestValue("FPA_WireOutValues");

        return FPA_WireOutValues[21];

      }

    /**
    *  Set the register0
    * @param {number} level_p - level of indentation at the beginning
    * @param {number} mode_p - define the print output
    * @param {number} verbosity_p - level of verbosity
    *  [7]: rst
    *     1: Software reset applied – resets all internal registers and self-clears to 0.
    *     0: do nothing
    *  [0] : serial_out
    *     0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).
    *     1: Serial readout enabled, Pin SDOUT functions as serial data readout.
    */
    function adc_set_config0(rst_p,serial_out_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

            level0 = level_p;
            level1 = level_p + 1;
            level2 = level_p + 2;
            level3 = level_p + 3;
            verbosity0 = 0;
            verbosity1 = verbosity0 + 1;
            verbosity2 = verbosity0 + 2;

            data = (rst_p << 7) + serial_out_p;
            addr = ADC_ADDR['reg0'];            
            adc_write_command(addr_p= addr,data_p=data);

            // print message
            if (verbosity_p >= verbosity0)
                {
                    msg = '[adc_set_config0]: Configure ADC register';
                    display_subtitle(msg_p=msg, level_p=level0, mode_p=mode_p);
                }
            if (verbosity_p >= verbosity1)
                {
                    msg = [
                           'Device ADDR: 0x'+ addr.toString(16),
                           'Device DATA: 0x' + data.toString(16)
                           ];                    
                    display(msg_p=msg, level_p=level1, mode_p=mode_p);
                }

            if (verbosity_p >= verbosity2)
                {
                    msg = [
                        'rst: 0x' + rst_p.toString(16),
                        'serial_out_p: 0x' + serial_out_p.toString(16)
                        ];

                    display(msg_p=msg, level_p=level2, mode_p=mode_p);
                }

        }

    /**
    * ###############################################################
    *  register1
    * ###############################################################
    *  [2]: enable_low_speed
    *  0: LOW SPEED mode disabled. Use for sampling frequency > 80 MSPS
    *  1: Enable LOW SPEED mode for sampling frequencies ≤ 80 MSPS.
    */
    function adc_set_config1(enable_low_speed_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

            data = (enable_low_speed_p << 2);
            addr = ADC_ADDR['reg1'];
            adc_write_command(addr_p=addr,data_p=data);

        }

    /**
    * ###############################################################
    *  register2
    * ###############################################################
    *  [6:5] ref: Internal or external reference selection
    *       00 : Internal reference enabled
    *       01:
    *       10:
    *       11: External reference enabled
    *  [1]: standby <STANDBY>
    *       0 Normal operation
    *       1 Both ADC channels are put in standby. Internal references, output buffers are active. This results in
    *    quick wake-up time from standby.
    */
    function adc_set_config2(ref_p,standby_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

            data = (ref_p << 5) + (standby_p << 1);
            addr = ADC_ADDR['reg2'];
            adc_write_command(addr_p=addr,data_p=data);


        }

    /**
    * ###############################################################
    *  register3
    * ###############################################################
    *  [3:0]: power_down
    *    0000 Pins CTRL1, CTRL2, and CTRL3 determine power down modes.
    *    1000 Normal operation
    *    1001 Output buffer disabled for channel B
    *    1010 Output buffer disabled for channel A
    *    1011 Output buffer disabled for channel A and B
    *    1100 Global power down
    *    1101 Channel B standby
    *    1110 Channel A standby
    *    1111 Multiplexed mode, MUX- (only with CMOS interface)
    *       Channel A and B data is multiplexed and output on DA13 to DA0 pins. Refer to the Multiplexed
    *       Output Mode section in the APPLICATION INFORMATION for additional information.
    */
    function adc_set_config3(power_down_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

            data = power_down_p;
            addr = ADC_ADDR['reg3'];
            adc_write_command(addr_p=addr,data_p=data);


        }

    /**
    * ###############################################################
    *  register4
    * ###############################################################
    *  [7]: lvds_cmos
    *    0 Parallel CMOS interface
    *    1 DDR LVDS interface
    */
    function adc_set_config4(lvds_cmos_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;
            data = (lvds_cmos_p << 7);
            addr = ADC_ADDR['reg4'];
            adc_write_command(addr_p=addr,data_p=data);
        }

    /**
    * ###############################################################
    *  register5
    * ###############################################################
    *  LVDS interface
    *     [7:5] clkout_pos_rise Output clock rising edge position (2)
    *        000, 100 Default output clock position (refer to timing specification table)
    *        101 Falling edge shifted (delayed) by + (4/26)×Ts(1)
    *        110 Falling edge shifted (advanced) by – (7/26)×Ts
    *        111 Falling edge shifted (advanced) by – (4/26)×Ts
    *     [4:2] clkout_pos_fall Output clock falling edge position (2)
    *        000, 100 Default output clock position (refer to timing specification table)
    *        101 Rising edge shifted (delayed) by + (4/26)×Ts
    *        110 Rising edge shifted (advanced) by – (7/26)×Ts
    *        111 Rising edge shifted (advanced) by – (4/26)×Ts
    *  CMOS interface
    *     [7:5]: clkout_pos_rise Output clock rising edge position (2)
    *        000, 100 Default output clock position (refer to timing specification table)
    *        101 Rising edge shifted (delayed) by + (4/26)×Ts
    *        110 Rising edge shifted (advanced) by – (7/26)×Ts
    *        111 Rising edge shifted (advanced) by – (4/26)×Ts
    *     [4:2] clkout_pos_fall Output clock falling edge position (2)
    *        000, 100 Default output clock position (refer to timing specification table)
    *        101 Falling edge shifted (delayed) by + (4/26)×Ts
    *        110 Falling edge shifted (advanced) by – (7/26)×Ts
    *        111 Falling edge shifted (advanced) by – (4/26)×Ts
    *  Note: 
    *        (1) Ts = 1 / sampling frequency
    *        (2) Keep the same duty cycle, move both edges by the same amount (i.e., write both D<4:2> and D<7:5> to be
    *        the same value).
    */
    function adc_set_config5(clkout_pos_rise_p,clkout_pos_fall_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

            data = (clkout_pos_rise_p << 5) + clkout_pos_fall_p;
            addr = ADC_ADDR['reg5'];
            adc_write_command(addr_p=addr,data_p=data);
        }

    /**
    * ###############################################################
    *  register6
    * ###############################################################
    *  [6]: en_independant_chan_ctrl
    *     0 Common control – both channels use common control settings for test patterns, offset correction,
    *       fine gain, gain correction and SNR Boost functions. These settings can be specified in a single set of registers.
    *     1 Independent control – both channels can be programmed with independent control settings for test
    *       patterns, offset correction and SNR Boost functions. Separate registers are available for each channel.
    *  [2:1]: data_format
    *    10 2s complement
    *    11 Offset binary
    */
    function adc_set_config6(en_independant_chan_ctrl_p,data_format_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

            data = (en_independant_chan_ctrl_p << 6) + (data_format_p << 1);
            addr = ADC_ADDR['reg6'];
            adc_write_command(addr_p=addr,data_p=data);
        }

    /*
    * ###############################################################
    *  register7
    * ###############################################################
    *  [7:0] custom_pattern_low
    *    8 lower bits of custom pattern available at the output instead of ADC data.
    *  Note: Use this mode along with “Test Patterns” (register 0x62).
    */
    function adc_set_config7(custom_patter_low_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

            data = custom_patter_low_p;
            addr = ADC_ADDR['reg7'];
            adc_write_command(addr_p=0x51,data_p=data);
        }

    /*
    * ###############################################################
    *  register8
    * ###############################################################
    *  [5:0] custom_pattern_high
    *    6 upper bits of custom pattern available at the output instead of ADC data
    *  Note: Use this mode along with “Test Patterns” (register 0x62).
    */
    function adc_set_config8(custom_patter_high_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

            data = custom_patter_high_p;
            addr = ADC_ADDR['reg8'];
            adc_write_command(addr_p=addr,data_p=data);
        }

    /*
    * ###############################################################
    *  register9
    * ###############################################################
    *  [6]:  en_offset_correction – Common/Ch A>
    *       Offset correction enable control for both channels (with common control) or for channel A only (with
    *       independent control).
    *    0 Offset correction disabled
    *    1 Offset correction enabled
    */
    function adc_set_config9(en_offset_correction_cha_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

            data = (en_offset_correction_cha_p << 6);
            addr = ADC_ADDR['reg9'];
            adc_write_command(addr_p=addr,data_p=data);
        }
    /**
    * ###############################################################
    *  register10
    * ###############################################################
    *  [7:4] gain_common_or_cha <GAIN – Common/Ch A>
    *   Gain control for both channels (with common control) or for channel A only (with independent control).
    *     0000 0 dB gain, default after reset
    *     0001 0.5 dB gain
    *     0010 1.0 dB gain
    *     0011 1.5 dB gain
    *     0100 2.0 dB gain
    *     0101 2.5 dB gain
    *     0110 3.0 dB gain
    *     0111 3.5 dB gain
    *     1000 4.0 dB gain
    *     1001 4.5 dB gain
    *     1010 5.0 dB gain
    *     1011 5.5 dB gain
    *     1100 6.0 dB gain
    *  [3:0] offset_corr_time_common_or_cha <OFFSET CORR TIME CONSTANT – Common/Ch A>
    *     Correction loop time constant in number of clock cycles.
    *     Applies to both channels (with common control) or for channel A only (with independent control).
    *     0000 256 k
    *     0001 512 k
    *     0010 1 M
    *     0011 2 M
    *     0100 4 M
    *     0101 8 M
    *     0110 16 M
    *     0111 32 M
    *     1000 64 M
    *     1001 128 M
    *     1010 256 M
    *     1011 512 M
    */
    function adc_set_config10(gain_common_or_cha_p,offset_corr_time_common_or_cha_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

            data = (gain_common_or_cha_p << 4) + offset_corr_time_common_or_cha_p;
            addr = ADC_ADDR['reg10'];
            adc_write_command(addr_p=addr,data_p=data);

        }
    /**
    * ###############################################################
    * register11
    * ###############################################################
    * [6:0] fine_gain_adjust_common_or_cha
    * Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
    * additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
    * trimmed channel gain is:
    *     Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
    * Note: that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
    *      <GAIN PROGRAMMABILITY>
    */
    function adc_set_config11(fine_gain_adjust_common_or_cha_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

              data = (fine_gain_adjust_common_or_cha_p);
              addr = ADC_ADDR['reg11'];
              adc_write_command(addr_p=addr,data_p=data);

        }
    /**
    * ###############################################################
    * register12
    * ###############################################################
    * [2:0] test_pattern_common_or_cha Test Patterns to verify data capture.
    *   Applies to both channels (with common control) or for channel A only (with independent control).
    *   000 Normal operation
    *   001 Outputs all zeros
    *   010 Outputs all ones
    *   011 Outputs toggle pattern – see Figure 14 and Figure 15 for test pattern timing diagrams for LVDS and CMOS modes.
    *       In ADS62P49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
    *       In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
    *   100 Outputs digital ramp
    *        In ADS62P49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
    *        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
    *   101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
    *   110 Unused
    *   111 Unused
    */
    function adc_set_config12(test_pattern_common_or_cha_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

              data = (test_pattern_common_or_cha_p);
               addr = ADC_ADDR['reg12'];
              adc_write_command(addr_p=addr,data_p=data);

        }

    /**
    * ###############################################################
    *  register13
    * ###############################################################
    *  [5:0]: offset_pedestal_common_or_cha <OFFSET PEDESTAL – Common/Ch A>
    *        When the offset correction is enabled, the final converged value (after the offset is corrected) will
    *        be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
    *        added to the final converged value by programming these bits. So, the final converged value will
    *        be = ideal mid-code + PEDESTAL.
    *        See "Offset Correction" in application section.
    *        Applies to both channels (with common control) or for channel A only (with independent control).
    *     011111 PEDESTAL = 31 LSB
    *     011110 PEDESTAL = 30 LSB
    *     011101 PEDESTAL = 29 LSB
    *     ...
    *     000000 PEDESTAL = 0
    *     ...
    *     111111 PEDESTAL = –1 LSB
    *     111110 PEDESTAL = –2 LSB
    *     ...
    *     100000 PEDESTAL = –32 LSB
    */

    function adc_set_config13(offset_pedestal_common_or_cha_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

            data = (offset_pedestal_common_or_cha_p);
            addr = ADC_ADDR['reg13'];
            adc_write_command(addr_p=addr,data_p=data);

        }

    /**
    * ###############################################################
    *  register14
    * ###############################################################
    *  [6] offset_corr_chb
    *      Offset correction enable control for channel B (only with independent control).
    *    0 offset correction disabled
    *    1 offset correction enabled
    */

    function adc_set_config14(offset_corr_chb_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

             data = (offset_corr_chb_p << 6);
             addr = ADC_ADDR['reg14'];
             adc_write_command(addr_p=addr,data_p=data);

        }
    /**
    * ###############################################################
    *  register15
    * ###############################################################
    *  [7:4] gain_chb Gain programmability to 0.5 dB steps.
    *        Applies to channel B (only with independent control).
    *     0000 0 dB gain, default after reset
    *     0001 0.5 dB gain
    *     0010 1.0 dB gain
    *     0011 1.5 dB gain
    *     0100 2.0 dB gain
    *     0101 2.5 dB gain
    *     0110 3.0 dB gain
    *     0111 3.5 dB gain
    *     1000 4.0 dB gain
    *     1001 4.5 dB gain
    *     1010 5.0 dB gain
    *     1011 5.5 dB gain
    *     1100 6.0 dB gain
    *  [3:0] offset_corr_time_chb Time constant of correction loop in number of clock cycles.
    *        Applies to channel B (only with independent control)
    *   0000 256 k
    *   0001 512 k
    *   0010 1 M
    *   0011 2 M
    *   0100 4 M
    *   0101 8 M
    *   0110 16 M
    *   0111 32 M
    *   1000 64 M
    *   1001 128 M
    *   1010 256 M
    *   1011 512 M
    */
    function adc_set_config15(gain_chb_p,offset_corr_time_chb_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

            data = (gain_chb_p << 4) + offset_corr_time_chb_p;
            addr = ADC_ADDR['reg15'];
            adc_write_command(addr_p=addr,data_p=data);
        }

    /**
    * ###############################################################
    * register16
    * ###############################################################
    * [7:0] fine_gain_adjust_chb
    *     Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
    *     additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
    *     trimmed channel gain is:
    *        Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
    * Note that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
    *  <GAIN PROGRAMMABILITY>
    */
    function adc_set_config16(fine_gain_adjust_chb_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
            if (typeof(level_p)==='undefined') level_p = 0;
            if (typeof(mode_p)==='undefined') mode_p = 0;
            if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

            data = fine_gain_adjust_chb_p;
            addr = ADC_ADDR['reg16'];
            adc_write_command(addr_p=addr,data_p=data);
        }
    /**
    * ###############################################################
    *  register17
    * ###############################################################
    *  [2:0]: test_pattern_chb Test Patterns to verify data capture.
    *        Applies to channel B (only with independent control)
    *      000 Normal operation
    *      001 Outputs all zeros
    *      010 Outputs all ones
    *      011 Outputs toggle pattern – see Figure 14 and Figure 15 for LVDS and CMOS modes.
    *         In ADS62P49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
    *         In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
    *      100 Outputs digital ramp
    *         In ADS62P49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
    *         In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
    *      101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
    *      110 Unused
    *      111 Unused
    */

  function adc_set_config17(test_pattern_chb_p,level_p,mode_p,verbosity_p)
    {
        // default function parameter values
        if (typeof(level_p)==='undefined') level_p = 0;
        if (typeof(mode_p)==='undefined') mode_p = 0;
        if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

        data = test_pattern_chb_p;
        addr = ADC_ADDR['reg17'];
        adc_write_command(addr_p=addr,data_p=data);
    }

    /**
    * ###############################################################
    *  register18
    * ###############################################################
    *  [5:0]: offset_pedestal_common_or_chb
    *        When the offset correction is enabled, the final converged value (after the offset is corrected) will
    *        be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
    *        added to the final converged value by programming these bits. So, the final converged value will
    *        be = ideal mid-code + PEDESTAL. See "Offset Correction" in application section.
    *        Applies to channel B (only with independent control).
    *    011111 PEDESTAL = 31 LSB
    *    011110 PEDESTAL = 30 LSB
    *    011101 PEDESTAL = 29 LSB
    *    ...
    *    000000 PEDESTAL = 0
    *    ...
    *    111111 PEDESTAL = –1 LSB
    *    111110 PEDESTAL = –2 LSB
    *    ...
    *    100000 PEDESTAL = –32 LSB
    */
    function adc_set_config18(offset_pedestal_common_or_chb_p,level_p,mode_p,verbosity_p)
        {
            // default function parameter values
        if (typeof(level_p)==='undefined') level_p = 0;
        if (typeof(mode_p)==='undefined') mode_p = 0;
        if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

            data = offset_pedestal_common_or_chb_p;
            addr = ADC_ADDR['reg18'];
            adc_write_command(addr_p=addr,data_p=data);
        }

    function adc_get_config(reg_id)
    {

        if (reg_id == 7)
        {
		   addr = 0x51
           value = adc_read_command(addr_p=addr);
           print('custom_patter_low_p: 0x', value.toString(16))
        }

    }



/**
 * Configure the CDCE72010 Device
 * @param {string} msg_p - subTitle to print (string or array of strings)
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the output print
 * @param {string} color_p - define the message color. The list of colors can be found in the common.console_colors
 */
function ADS62P49_configure(level_p,mode_p,verbosity_p)
{
    // default function parameter values
        if (typeof(level_p)==='undefined') level_p = 0;
        if (typeof(mode_p)==='undefined') mode_p = 0;
        if (typeof(verbosity_p)==='undefined') verbosity_p = 0;
    adc_init_device();
        /*
    //###############################################################
    // register0
    //###############################################################
    // [7]: rst
    //    1: Software reset applied – resets all internal registers and self-clears to 0.
    //    0: do nothing
    // [0] : serial_out
    //    0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).
    //    1: Serial readout enabled, Pin SDOUT functions as serial data readout.
    */
    rst = 1;  //  Software reset applied – resets all internal registers and self-clears to 0.
    serial_out = 0; //0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).1:Serial readout enabled, Pin SDOUT functions as serial data readout.
    adc_set_config0(rst_p = rst, serial_out_p = serial_out);

    /*
    //###############################################################
    // register1
    //###############################################################
    // [2]: enable_low_speed
    //      0: LOW SPEED mode disabled. Use for sampling frequency > 80 MSPS
    //      1: Enable LOW SPEED mode for sampling frequencies ≤ 80 MSPS.
    */
    enable_low_speed = 0;
    adc_set_config1(enable_low_speed_p=enable_low_speed);
    

    /*
    //###############################################################
    // register2
    //###############################################################
    // [6] ref: Internal or external reference selection
    //      00 : Internal reference enabled
    //      01:
    //      10:
    //      11: External reference enabled
    // [1]: standby <STANDBY>
    //      0 Normal operation
    //      1 Both ADC channels are put in standby. Internal references, output buffers are active. This results in
    //   quick wake-up time from standby.
    */
    ref = parseInt('00',2);
    standby = 0;
    adc_set_config2(ref_p=ref,standby_p=standby);

    /*
    //###############################################################
    // register3
    //###############################################################
    // [3:0]: power_down
    //   0000 Pins CTRL1, CTRL2, and CTRL3 determine power down modes.
    //   1000 Normal operation
    //   1001 Output buffer disabled for channel B
    //   1010 Output buffer disabled for channel A
    //   1011 Output buffer disabled for channel A and B
    //   1100 Global power down
    //   1101 Channel B standby
    //   1110 Channel A standby
    //   1111 Multiplexed mode, MUX- (only with CMOS interface)
    //      Channel A and B data is multiplexed and output on DA13 to DA0 pins. Refer to the Multiplexed
    //      Output Mode section in the APPLICATION INFORMATION for additional information.
    */
    power_down = parseInt('1000',2);
    adc_set_config3(power_down_p=power_down);

    /*
    //###############################################################
    // register4
    //###############################################################
    // [7]: lvds_cmos
    //   0 Parallel CMOS interface
    //   1 DDR LVDS interface
    */
    lvds_cmos = 1;
    adc_set_config4(lvds_cmos_p=lvds_cmos);

    /*
    //###############################################################
    // register5
    //###############################################################
    // LVDS interface
    //    [7:5] clkout_pos_rise Output clock rising edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Falling edge shifted (delayed) by + (4/26)×Ts(1)
    //       110 Falling edge shifted (advanced) by – (7/26)×Ts
    //       111 Falling edge shifted (advanced) by – (4/26)×Ts
    //    [4:2] clkout_pos_fall Output clock falling edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Rising edge shifted (delayed) by + (4/26)×Ts
    //       110 Rising edge shifted (advanced) by – (7/26)×Ts
    //       111 Rising edge shifted (advanced) by – (4/26)×Ts
    // CMOS interface
    //    [7:5]: clkout_pos_rise Output clock rising edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Rising edge shifted (delayed) by + (4/26)×Ts
    //       110 Rising edge shifted (advanced) by – (7/26)×Ts
    //       111 Rising edge shifted (advanced) by – (4/26)×Ts
    //    [4:2] clkout_pos_fall Output clock falling edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Falling edge shifted (delayed) by + (4/26)×Ts
    //       110 Falling edge shifted (advanced) by – (7/26)×Ts
    //       111 Falling edge shifted (advanced) by – (4/26)×Ts
    // Note: 
    //       (1) Ts = 1 / sampling frequency
    //       (2) Keep the same duty cycle, move both edges by the same amount (i.e., write both D<4:2> and D<7:5> to be
    //       the same value).
    */
    clkout_pos_rise = parseInt('000',2);
    clkout_pos_fall = parseInt('000',2);
    adc_set_config5(clkout_pos_rise_p=clkout_pos_rise,clkout_pos_fall_p=clkout_pos_fall);

    /*
    //###############################################################
    // register6
    //###############################################################
    // [6]: en_independant_chan_ctrl
    //    0 Common control – both channels use common control settings for test patterns, offset correction,
    //      fine gain, gain correction and SNR Boost functions. These settings can be specified in a single set of registers.
    //    1 Independent control – both channels can be programmed with independent control settings for test
    //      patterns, offset correction and SNR Boost functions. Separate registers are available for each channel.
    // [2:1]: data_format
    //   10 2s complement
    //   11 Offset binary
    */
    en_independant_chan_ctrl = 1;
    data_format = parseInt('10',2);
    adc_set_config6(en_independant_chan_ctrl_p=en_independant_chan_ctrl,data_format_p=data_format);

    /*
    //###############################################################
    // register7
    //###############################################################
    // [7:0] custom_pattern_low
    //   8 lower bits of custom pattern available at the output instead of ADC data.
    // Note: Use this mode along with “Test Patterns” (register 0x62).
    */
    custom_patter_low = parseInt('10011111',2);
    adc_set_config7(custom_patter_low_p=custom_patter_low);

    /*
    //###############################################################
    // register8
    //###############################################################
    // [5:0] custom_pattern_high
    //   6 upper bits of custom pattern available at the output instead of ADC data
    // Note: Use this mode along with “Test Patterns” (register 0x62).
    */
    custom_patter_high = parseInt('100000',2);
    adc_set_config8(custom_patter_high_p=custom_patter_high);

    /*
    //###############################################################
    // register9
    //###############################################################
    // [6]:  en_offset_correction – Common/Ch A>
    //      Offset correction enable control for both channels (with common control) or for channel A only (with
    //      independent control).
    //   0 Offset correction disabled
    //   1 Offset correction enabled
    */
    en_offset_correction_cha = 0;
    adc_set_config9(en_offset_correction_cha_p=en_offset_correction_cha);

    /*
    //###############################################################
    // register10
    //###############################################################
    // [7:4] gain_common_or_cha <GAIN – Common/Ch A>
    //  Gain control for both channels (with common control) or for channel A only (with independent control).
    //    0000 0 dB gain, default after reset
    //    0001 0.5 dB gain
    //    0010 1.0 dB gain
    //    0011 1.5 dB gain
    //    0100 2.0 dB gain
    //    0101 2.5 dB gain
    //    0110 3.0 dB gain
    //    0111 3.5 dB gain
    //    1000 4.0 dB gain
    //    1001 4.5 dB gain
    //    1010 5.0 dB gain
    //    1011 5.5 dB gain
    //    1100 6.0 dB gain
    // [3:0] offset_corr_time_common_or_cha <OFFSET CORR TIME CONSTANT – Common/Ch A>
    //    Correction loop time constant in number of clock cycles.
    //    Applies to both channels (with common control) or for channel A only (with independent control).
    //    0000 256 k
    //    0001 512 k
    //    0010 1 M
    //    0011 2 M
    //    0100 4 M
    //    0101 8 M
    //    0110 16 M
    //    0111 32 M
    //    1000 64 M
    //    1001 128 M
    //    1010 256 M
    //    1011 512 M
    */
    gain_cha = parseInt('0000',2);
    offset_corr_time_cha = parseInt('0000',2);
    adc_set_config10(gain_common_or_cha_p=gain_cha,offset_corr_time_common_or_cha_p=offset_corr_time_cha);

    //###############################################################
    // register11
    //###############################################################
    // [6:0] fine_gain_adjust_common_or_cha
    // Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
    // additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
    // trimmed channel gain is:
    //     Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
    // Note: that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
    //      <GAIN PROGRAMMABILITY>
    fine_gain_adjust_common_or_cha = parseInt('0000000',2);
    adc_set_config11(fine_gain_adjust_common_or_cha_p=fine_gain_adjust_common_or_cha);

    //###############################################################
    // register12
    //###############################################################
    // [2:0] test_pattern_common_or_cha Test Patterns to verify data capture.
    //   Applies to both channels (with common control) or for channel A only (with independent control).
    //   000 Normal operation
    //   001 Outputs all zeros
    //   010 Outputs all ones
    //   011 Outputs toggle pattern – see Figure 14 and Figure 15 for test pattern timing diagrams for LVDS and CMOS modes.
    //       In ADS62P49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
    //       In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
    //   100 Outputs digital ramp
    //        In ADS62P49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
    //        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
    //   101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
    //   110 Unused
    //   111 Unused
    test_pattern_common_or_cha = parseInt('000',2);
    adc_set_config12(test_pattern_common_or_cha_p=test_pattern_common_or_cha);

    //###############################################################
    // register13
    //###############################################################
    // [5:0]: offset_pedestal_common_or_cha <OFFSET PEDESTAL – Common/Ch A>
    //       When the offset correction is enabled, the final converged value (after the offset is corrected) will
    //       be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
    //       added to the final converged value by programming these bits. So, the final converged value will
    //       be = ideal mid-code + PEDESTAL.
    //       See "Offset Correction" in application section.
    //       Applies to both channels (with common control) or for channel A only (with independent control).
    //    011111 PEDESTAL = 31 LSB
    //    011110 PEDESTAL = 30 LSB
    //    011101 PEDESTAL = 29 LSB
    //    ...
    //    000000 PEDESTAL = 0
    //    ...
    //    111111 PEDESTAL = –1 LSB
    //    111110 PEDESTAL = –2 LSB
    //    ...
    //    100000 PEDESTAL = –32 LSB
    offset_pedestal_common_or_cha = parseInt('000000',2);
    adc_set_config13(offset_pedestal_common_or_cha_p=offset_pedestal_common_or_cha);

    //###############################################################
    // register14
    //###############################################################
    // [6] offset_corr_chb
    //     Offset correction enable control for channel B (only with independent control).
    //   0 offset correction disabled
    //   1 offset correction enabled
    offset_corr_chb = 0;
    adc_set_config14(offset_corr_chb_p=offset_corr_chb);

    //###############################################################
    // register15
    //###############################################################
    // [7:4] gain_chb Gain programmability to 0.5 dB steps.
    //       Applies to channel B (only with independent control).
    //    0000 0 dB gain, default after reset
    //    0001 0.5 dB gain
    //    0010 1.0 dB gain
    //    0011 1.5 dB gain
    //    0100 2.0 dB gain
    //    0101 2.5 dB gain
    //    0110 3.0 dB gain
    //    0111 3.5 dB gain
    //    1000 4.0 dB gain
    //    1001 4.5 dB gain
    //    1010 5.0 dB gain
    //    1011 5.5 dB gain
    //    1100 6.0 dB gain
    // [3:0] offset_corr_time_chb Time constant of correction loop in number of clock cycles.
    //       Applies to channel B (only with independent control)
    //  0000 256 k
    //  0001 512 k
    //  0010 1 M
    //  0011 2 M
    //  0100 4 M
    //  0101 8 M
    //  0110 16 M
    //  0111 32 M
    //  1000 64 M
    //  1001 128 M
    //  1010 256 M
    //  1011 512 M
    gain_chb = parseInt('0000',2);
    offset_corr_time_chb = parseInt('0000',2);
    adc_set_config15(gain_chb_p=gain_chb,offset_corr_time_chb_p=offset_corr_time_chb);

    //###############################################################
    // register16
    //###############################################################
    // [7:0] fine_gain_adjust_chb
    //     Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
    //     additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
    //     trimmed channel gain is:
    //        Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
    // Note that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
    //  <GAIN PROGRAMMABILITY>
    fine_gain_adjust_chb = parseInt('0000000',2);
    adc_set_config16(fine_gain_adjust_chb_p=fine_gain_adjust_chb);

    //###############################################################
    // register17
    //###############################################################
    // [2:0]: test_pattern_chb Test Patterns to verify data capture.
    //       Applies to channel B (only with independent control)
    //     000 Normal operation
    //     001 Outputs all zeros
    //     010 Outputs all ones
    //     011 Outputs toggle pattern – see Figure 14 and Figure 15 for LVDS and CMOS modes.
    //        In ADS62P49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
    //        In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
    //     100 Outputs digital ramp
    //        In ADS62P49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
    //        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
    //     101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
    //     110 Unused
    //     111 Unused
    test_pattern_chb = parseInt('000',2);
    adc_set_config17(test_pattern_chb_p=test_pattern_chb);

    //###############################################################
    // register18
    //###############################################################
    // [5:0]: offset_pedestal_common_or_chb
    //       When the offset correction is enabled, the final converged value (after the offset is corrected) will
    //       be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
    //       added to the final converged value by programming these bits. So, the final converged value will
    //       be = ideal mid-code + PEDESTAL. See "Offset Correction" in application section.
    //       Applies to channel B (only with independent control).
    //   011111 PEDESTAL = 31 LSB
    //   011110 PEDESTAL = 30 LSB
    //   011101 PEDESTAL = 29 LSB
    //   ...
    //   000000 PEDESTAL = 0
    //   ...
    //   111111 PEDESTAL = –1 LSB
    //   111110 PEDESTAL = –2 LSB
    //   ...
    //   100000 PEDESTAL = –32 LSB
    offset_pedestal_common_or_chb = parseInt('000000',0);
    adc_set_config18(offset_pedestal_common_or_chb_p=offset_pedestal_common_or_chb);





}