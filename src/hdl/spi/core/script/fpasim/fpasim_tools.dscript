// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                   fpasim_tools.dscript
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference    
// -------------------------------------------------------------------------------------------------------------
//    @details                
//
// -------------------------------------------------------------------------------------------------------------
include("./fpasim/utils_tools.dscript")
include("./fpasim/CDCE72010.dscript")
include("./fpasim/ADS62P49.dscript")
include("./fpasim/DAC3283.dscript")
include("./fpasim/AMC7823.dscript")

// verbosity min to display register access
const c_FPASIM_REG_VERBOSITY_MIN = 0;
// verbosity min to display (addr,data)
const c_FPASIM_ADDR_VERBOSITY_MIN = 1;
// verbosity min to display register bit
const c_FPASIM_BIT_VERBOSITY_MIN = c_FPASIM_ADDR_VERBOSITY_MIN + 1;

/**
 * Reset the fpasim function
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function fpasim_reset(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    // Reset: CTRL
    rst = 1;
    en = 0;
    data = (rst << 1) + en;

    msg = "CTRL: Reset On"
    display(msg_p = msg, level_p = level0, mode_p = mode_p);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'CTRL', data_p = data, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    // Reset SPI_CTRL
    rst = 1;
    en = 0;
    data = (rst << 1) + en;

    msg = "SPI_CTRL: Reset On"
    display(msg_p = msg, level_p = level0, mode_p = mode_p);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'SPI_CTRL', data_p = data, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    // Reset DEBUG_CTRL
    rst_status = 1;
    debug_pulse = 0;
    data = (rst_status << 1) + en;

    msg = "DEBUG_CTRL: Reset On"
    display(msg_p = msg, level_p = level0, mode_p = mode_p);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'DEBUG_CTRL', data_p = data, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    // Set tempo: 
    msg = "Set tempo"
    display(msg_p = msg, level_p = level0, mode_p = mode_p);
    waitMs(100);

    // Reset: CTRL
    rst = 0;
    en = 0;
    data = (rst << 1) + en;

    msg = "CTRL: Reset Off"
    display(msg_p = msg, level_p = level0, mode_p = mode_p);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'CTRL', data_p = data, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    // Reset SPI_CTRL
    rst = 0;
    en = 0;
    data = (rst << 1) + en;

    msg = "SPI_CTRL: Reset Off"
    display(msg_p = msg, level_p = level0, mode_p = mode_p);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'SPI_CTRL', data_p = data, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    // Reset DEBUG_CTRL
    rst_status = 0;
    debug_pulse = 0;
    data = (rst_status << 1) + en;

    msg = "DEBUG_CTRL: Reset Off"
    display(msg_p = msg, level_p = level0, mode_p = mode_p);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'DEBUG_CTRL', data_p = data, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
}

function fpasim_build_ctrl(rst_p, en_p) {
    data = (rst_p << 1) + en_p;

    return data;
}

function fpasim_build_make_pulse(pixel_all_p, pixel_id_p, time_shift_p, pulse_height_p) {
    data = (pixel_all_p << 31) + (pixel_id_p << 24) + (time_shift_p << 16) + (pulse_height_p)
    return data;
}

function fpasim_build_fpasim_gain(fpasim_gain_p) {
    data = fpasim_gain_p;
    return data;
}

function fpasim_build_mux_sq_fb_delay(mux_sq_fb_delay_p) {
    data = mux_sq_fb_delay_p;
    return data;
}

function fpasim_build_amp_sq_of_delay(amp_sq_of_delay_p) {
    data = amp_sq_of_delay_p;
    return data;
}

function fpasim_build_error_delay(error_delay_p) {
    data = error_delay_p;
    return data;
}

function fpasim_build_ra_delay(ra_delay_p) {
    data = ra_delay_p;
    return data;
}

function fpasim_build_tes_conf(nb_pixel_by_frame_p, nb_sample_by_pixel_p, nb_samples_by_frame_p) {
    data = (nb_pixel_by_frame_p << 24) + (nb_sample_by_pixel_p << 16) + nb_samples_by_frame_p;
    return data;
}

function fpasim_build_spi_ctrl(rst_p, en_p) {
    data = (rst_p << 1) + (en_p);
    return data;
}

/**
 *  Set the spi_ctrl register
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [1]: rst_p
 *    .'1': reset the SPI module
 *    .'0': do nothing
 *  [0] : serial_out
 *    .'1': enable the SPI module
 *    .'0': disable the SPI module after the last SPI transaction is finished.
 */
// function fpasim_set_spi_ctrl(rst_p, en_p, level_p, mode_p, verbosity_p) {
//     // default function parameter values
//     if (typeof(level_p) === 'undefined') level_p = 0;
//     if (typeof(mode_p) === 'undefined') mode_p = 0;
//     if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

//     const level0 = level_p;
//     const level1 = level_p + 1;
//     const level2 = level_p + 2;

//     data = fpasim_build_spi_ctrl(rst_p=rst_p,en_p=en_p);

//     const addr = FPASIM_ADDR_WIREIN['SPI_CTRL'];
//     adc_write_command(addr_p = addr, data_p = data);

//     if (verbosity_p < 0) {
//         // do nothing
//     } else {
//         if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
//             msg = "[adc_set_config0]: Set the register value: ";
//             display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
//         }

//         if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
//             display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
//         }

//         if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
//             display_bit(bit_name_p = "rst_p", bit_value_p = rst_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
//             display_bit(bit_name_p = "en_p", bit_value_p = en_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
//         }
//     }

// }

function fpasim_build_spi_conf(spi_dac_tx_en_p, spi_id_p, spi_mode_p) {
    data = (spi_dac_tx_en_p << 8) + (spi_id_p << 4) + spi_mode_p;
    return data;
}

function fpasim_build_spi_wr_data(data_p) {
    data = data_p;
    return data;
}

function fpasim_build_rec_ctrl(en_p) {
    data = en_p;
    return data;
}

function fpasim_build_rec_conf(rec_adc_nb_word_32b_p) {
    data = rec_adc_nb_word_32b_p;
    return data;
}

function fpasim_build_debug_ctrl(rst_status_p, debug_pulse_p) {
    data = (rst_status_p << 1) + debug_pulse_p;
    return data;
}

function fpasim_build_error_sel(sel_error_p) {
    data = sel_error_p;
    return data;
}



function fpasim_get_status(sel_error_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    // Select the errors to read
    const index = sel_error_p;
    fpasim_set_debug_wirein_by_name(reg_name_p = "ERROR_SEL", data_p = index, level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);

    fpasim_get_wireout_by_name(reg_name_p = "STATUS", level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);

    return data;
}





function fpasim_set_debug_wirein_by_name(reg_name_p, data_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    data = data_p;
    addr = 0;
    trig_addr = FPASIM_ADDR_TRIGIN['TRIG'];
    trig_pos = -1;
    error = 0;
    switch (reg_name_p) {
        case 'CTRL':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['ctrl_valid'];
            break;
        case 'MAKE_PULSE':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['make_pulse'];
            break;
        case 'FPASIM_GAIN':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;
        case 'MUX_SQ_FB_DELAY':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;
        case 'AMP_SQ_OF_DELAY':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;
        case 'ERROR_DELAY':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;
        case 'RA_DELAY':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;
        case 'TES_CONF':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;

            // case 'RFU':
            //   break;

            // case 'RFU':
            //   break;

            // case 'RFU':
            //   break;

            // case 'DATA_COUNT':
            //     break;
        case 'REC_CTRL':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            // trig_pos = FPASIM_POS_TRIGIN['rec_valid'];
            trig_pos = -1;
            break;
        case 'REC_CONF0':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['rec_valid'];
            break;

            // case 'RFU':
            //   break;

            // case 'RFU':
            //   break;

            // case 'RFU':
            //   break;

            // case 'REC_DATA_COUNT':
            //     break;

        case 'SPI_CTRL':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = -1;
            break;

        case 'SPI_CONF':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = -1;
            break;
        case 'SPI_WR_DATA':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['spi_valid'];
            break;
            // case 'SPI_RD_DATA':
            //     break;
        case 'SPI_STATUS':
            break;

            // case 'RFU':
            // break;

        case 'DEBUG_CTRL':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['debug_valid'];
            break;

        case 'ERROR_SEL':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = -1;
            break;

            // case 'ERRORS':
            //     break;

            // case 'STATUS':
            //     break;

            // case 'RFU':
            // data = FPA_WireOutValues[28];
            // break;

            // case 'BOARD_ID':
            //     break;
            // case 'FIRMWARE_ID':
            //     break;
            // case 'FIRMWARE_VERSION':
            //     break;
        default:
            msg = "[fpasim_get_wireout_by_name]: Error" + reg_name_p + " doesn't exist."
            display_error(msg_p = msg, level_p = level0, mode_p = mode_p);
            error = 1;
            break;
    }

    if (error == 0) {

        sendToFPA_debugSetWireIn(addr, data);

        if (trig_pos != -1) {
            sendToFPA_debugSetTriggerIn(trig_addr, trig_pos);
        }
        if (verbosity_p < 0) {
            // do nothing
        } else {

            if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
                msg = "[fpasim_set_debug_wirein_by_name]: Set " + reg_name_p;
                display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
            }

            if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
                display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
            }

            if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
                if (trig_pos != -1)
                    msg = "[fpasim_set_debug_wirein_by_name]: Set Trig (bit" + trig_pos.toString(10) + ")";
                display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
            }

        }


    }

}

function fpasim_wireout_read_command(addr_p) {
    // shift address
    const index = addr_p - 0x20;
    //---------------------------------------------------------------------
    // Read wire out registers
    //---------------------------------------------------------------------
    waitMs(500);
    getLatestValue("FPA_WireOutValues");
    const data = FPA_WireOutValues[index];

    return data;
}
/*
TODO
*/
function fpasim_get_wireout_ctrl(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['CTRL'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {

        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_ctrl]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "en", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "rst", bit_pos_p = 1, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_make_pulse(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['MAKE_PULSE'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_make_pulse]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "pulse_height", bit_pos_p = 0, bit_width_p = 11, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "time_shift", bit_pos_p = 16, bit_width_p = 4, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "pixel_id", bit_pos_p = 24, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "pixel_all", bit_pos_p = 31, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_fpasim_gain(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['FPASIM_GAIN'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {

        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_make_pulse]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "fpasim_gain_p", bit_pos_p = 0, bit_width_p = 3, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_mux_sq_fb_delay(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['MUX_SQ_FB_DELAY'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_mux_sq_fb_delay]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "gain_p", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_amp_sq_of_delay(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['AMP_SQ_OF_DELAY'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_amp_sq_of_delay]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "gain_p", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_error_delay(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['ERROR_DELAY'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_error_delay]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "gain_p", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_ra_delay(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['RA_DELAY'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_ra_delay]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "gain_p", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_tes_conf(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['TES_CONF'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_tes_conf]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "nb_sample_by_frame", bit_pos_p = 0, bit_width_p = 16, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "nb_sample_by_pixel", bit_pos_p = 0, bit_width_p = 7, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "nb_pixel_by_frame", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_data_count(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['DATA_COUNT'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_data_count]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "pipe_data_count", bit_pos_p = 0, bit_width_p = 16, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "make_pulse_wr_data_count", bit_pos_p = 16, bit_width_p = 16, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_rec_ctrl(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['REC_CTRL'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_rec_ctrl]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "rec_adc_en", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_rec_conf0(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['REC_CONF0'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_rec_conf0]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "rec_adc_nb_word_32b_p", bit_pos_p = 0, bit_width_p = 16, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_rec_data_count(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['REC_DATA_COUNT'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_rec_data_count]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "rec_adc_data_count_p", bit_pos_p = 0, bit_width_p = 16, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_spi_ctrl(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_CTRL'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_ctrl]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "rst_p", bit_pos_p = 1, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "en_p", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_spi_conf(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_CONF'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_conf]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "spi_dac_tx_enable_p", bit_pos_p = 8, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "spi_id_p", bit_pos_p = 4, bit_width_p = 2, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "spi_mode_p", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_spi_wr_data(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_WR_DATA'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_wr_data]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "wr_data_p", bit_pos_p = 0, bit_width_p = 32, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_spi_rd_data(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_RD_DATA'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_rd_data]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "rd_data_p", bit_pos_p = 0, bit_width_p = 32, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_spi_status(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_STATUS'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_status]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "spi_ready", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "cdce_pll_status", bit_pos_p = 4, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "amc_galr_n", bit_pos_p = 8, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_debug_ctrl(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['DEBUG_CTRL'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_debug_ctrl]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "rst_status", bit_pos_p = 1, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "debug_pulse", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_error_sel(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['ERROR_SEL'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_error_sel]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "sel_error", bit_pos_p = 1, bit_width_p = 4, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_errors(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['ERRORS'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_errors]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "errors", bit_pos_p = 0, bit_width_p = 32, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_status(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['STATUS'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_status]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "status", bit_pos_p = 0, bit_width_p = 32, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_board_id(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['BOARD_ID'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_board_id]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "board_id_p", bit_pos_p = 0, bit_width_p = 32, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

function fpasim_get_wireout_firmware_id(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['FIRMWARE_ID'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_firmware_id]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "firware_id_p", bit_pos_p = 0, bit_width_p = 32, data_p = data, level_p = level2, mode_p = mode_p);
            msg = "firware_id(ascii): " + convert_hex_to_ascii(value_p = data, width_p = 32);
            display(msg_p = msg, level_p = level2, mode_p = mode_p);
        }
    }



    return data;
}

function fpasim_get_wireout_firware_version(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['FIRMWARE_VERSION'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_firware_version]: Get the register value: ";
            display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "firware_version_p", bit_pos_p = 0, bit_width_p = 32, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}



/**
 * Get a specific wireout values
 * @param {string} reg_name_p - register name
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 * @return {object} dic.data - data value (all read bits)
 * @return {object} dic.error - error value
 * @return {object} dic.field_name(s) - (optional) value(s) of the differents fields, if exist
 */
function fpasim_get_wireout_by_name(reg_name_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    error = 0;
    data = 0;
    switch (reg_name_p) {
        case 'CTRL':
            data = fpasim_get_wireout_ctrl(level_p = level0, mode_p, verbosity_p);
            break;
        case 'MAKE_PULSE':
            data = fpasim_get_wireout_make_pulse(level_p = level0, mode_p, verbosity_p);
            break;
        case 'FPASIM_GAIN':
            data = fpasim_get_wireout_fpasim_gain(level_p = level0, mode_p, verbosity_p);
            break;
        case 'MUX_SQ_FB_DELAY':
            data = fpasim_get_wireout_mux_sq_fb_delay(level_p = level0, mode_p, verbosity_p);
            break;
        case 'AMP_SQ_OF_DELAY':
            data = fpasim_get_wireout_amp_sq_of_delay(level_p = level0, mode_p, verbosity_p);
            break;
        case 'ERROR_DELAY':
            data = fpasim_get_wireout_error_delay(level_p = level0, mode_p, verbosity_p);
            break;
        case 'RA_DELAY':
            data = fpasim_get_wireout_ra_delay(level_p = level0, mode_p, verbosity_p);
            break;
        case 'TES_CONF':
            data = fpasim_get_wireout_tes_conf(level_p = level0, mode_p, verbosity_p);
            break;

            // case 'RFU':
            //   data = FPA_WireOutValues[8];
            //   break;

            // case 'RFU':
            //   data = FPA_WireOutValues[9];
            //   break;

            // case 'RFU':
            //   data = FPA_WireOutValues[10];
            //   break;

        case 'DATA_COUNT':
            data = fpasim_get_wireout_data_count(level_p = level0, mode_p, verbosity_p);
            break;
        case 'REC_CTRL':
            data = fpasim_get_wireout_rec_ctrl(level_p = level0, mode_p, verbosity_p);
            break;
        case 'REC_CONF0':
            data = fpasim_get_wireout_rec_conf0(level_p = level0, mode_p, verbosity_p);
            break;

            // case 'RFU':
            //   data = FPA_WireOutValues[14];
            //   break;

            // case 'RFU':
            //   data = FPA_WireOutValues[15];
            //   break;

            // case 'RFU':
            //   data = FPA_WireOutValues[16];
            //   break;

        case 'REC_DATA_COUNT':
            data = fpasim_get_wireout_rec_data_count(level_p = level0, mode_p, verbosity_p);
            break;

        case 'SPI_CTRL':
            data = fpasim_get_wireout_spi_ctrl(level_p = level0, mode_p, verbosity_p);
            break;

        case 'SPI_CONF':
            data = fpasim_get_wireout_spi_conf(level_p = level0, mode_p, verbosity_p);
            break;
        case 'SPI_WR_DATA':
            data = fpasim_get_wireout_spi_wr_data(level_p = level0, mode_p, verbosity_p);
            break;
        case 'SPI_RD_DATA':
            data = fpasim_get_wireout_spi_rd_data(level_p = level0, mode_p, verbosity_p);
            break;
        case 'SPI_STATUS':
            data = fpasim_get_wireout_spi_status(level_p = level0, mode_p, verbosity_p);
            break;

            // case 'RFU':
            // data = FPA_WireOutValues[23];
            // break;

        case 'DEBUG_CTRL':
            data = fpasim_get_wireout_debug_ctrl(level_p = level0, mode_p, verbosity_p);
            break;

        case 'ERROR_SEL':
            data = fpasim_get_wireout_error_sel(level_p = level0, mode_p, verbosity_p);
            break;

        case 'ERRORS':
            data = fpasim_get_wireout_errors(level_p = level0, mode_p, verbosity_p);
            break;

        case 'STATUS':
            data = fpasim_get_wireout_status(level_p = level0, mode_p, verbosity_p);
            break;

            // case 'RFU':
            // data = FPA_WireOutValues[28];
            // break;

        case 'BOARD_ID':
            data = fpasim_get_wireout_board_id(level_p = level0, mode_p, verbosity_p);
            break;
        case 'FIRMWARE_ID':
            data = fpasim_get_wireout_firmware_id(level_p = level0, mode_p, verbosity_p);
            break;
        case 'FIRMWARE_VERSION':
            data = fpasim_get_wireout_firware_version(level_p = level0, mode_p, verbosity_p);
            break;
        default:
            msg = "[fpasim_get_wireout_by_name]: Error" + reg_name_p + " doesn't exist."
            display_error(msg_p = msg, level_p = level0, mode_p = mode_p);
            error = 1;
            break;
    }

    return data;


}

/**
 * Check the error specified by id
 * @param {number} sel_error_p - error id. The range is [0;10]
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function fpasim_get_error_by_id(sel_error_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    // Select the errors to read
    const data0 = fpasim_build_error_sel(sel_error_p = sel_error_p);
    fpasim_set_debug_wirein_by_name(reg_name_p = "ERROR_SEL", data_p = data0, level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);

    // read the selected errors
    const data = fpasim_get_wireout_by_name(reg_name_p = "ERRORS", level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);

    return data;
}

/**
 * Check if the specified error is equal to error_p
 * @param {number} error_id_p - error id. The range is [0;10]
 * @param {number} error_p - error value to compare
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function fpasim_check_error_by_id(error_id_p, error_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const data1 = error_p;

    data0 = fpasim_get_error_by_id(sel_error_p = error_id_p, level_p = level0, mode_p = mode_p, verbosity_p = -2);
    str_data0 = convert_int_to_str_hex(value_p=data0, width_p=32);
    str_data1 = convert_int_to_str_hex(value_p=data1, width_p=32);
    const msg_error = "Errors" + error_id_p.toString(10)+": Read Errors:0x"+str_data0+" - expected value: 0x"+str_data1;
    check_equal(value0_p = data0, value1_p = data1, msg_p = msg_error, level_p = level0, mode_p = mode_p);
}

/**
 * Check if all errors are equal to 0x0.
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function fpasim_check_all_errors(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;

    fpasim_check_error_by_id(error_id_p = 0,  error_p=0, level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    fpasim_check_error_by_id(error_id_p = 1,  error_p=0, level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    fpasim_check_error_by_id(error_id_p = 2,  error_p=0, level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    fpasim_check_error_by_id(error_id_p = 3,  error_p=0, level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    fpasim_check_error_by_id(error_id_p = 4,  error_p=0, level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    fpasim_check_error_by_id(error_id_p = 5,  error_p=0, level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    fpasim_check_error_by_id(error_id_p = 6,  error_p=0, level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    fpasim_check_error_by_id(error_id_p = 7,  error_p=0, level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    fpasim_check_error_by_id(error_id_p = 8,  error_p=0, level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    fpasim_check_error_by_id(error_id_p = 9,  error_p=0, level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    fpasim_check_error_by_id(error_id_p = 10, error_p=0,  level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);

}


/**
 * Configure the FMC150 SPI devices.
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 * @return {number} 0
 */
function configure_fmc150_spi_device(level_p, mode_p, verbosity_p) {

    CDCE72010_configure(level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);
    ADS62P49_configure(level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);
    DAC3283_configure(level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);
    AMC7823_configure(level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);

    return 0;

}

/**
 * Check if 2 values are equal
 * @param {number} value0_p - first value to compare
 * @param {number} value1_p - first value to compare
 * @param {string} msg_p - error message
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @return {number} 0
 */
function check_equal(value0_p, value1_p, msg_p, level_p, mode_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;


    if (value0_p !== value1_p) {
		msg_tmp = "[KO]: " + msg_p;
		display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
		
        const msg = [
            "[Error]: value0_p != value1_p",
            "[check_equal]: value0_p: 0x" + convert_int_to_str_hex(value_p = value0_p, width_p = 32),
            "[check_equal]: value1_p: 0x" + convert_int_to_str_hex(value_p = value1_p, width_p = 32)
        ];
        display(msg_p = msg, level_p = level1, mode_p = mode_p);
    }
	else
	{
		const msg = "[OK] "+ msg_p;
		display(msg_p = msg, level_p = level1, mode_p = mode_p);
	}
}

//---------------------------------------------------------------------------------------
// General functions
//---------------------------------------------------------------------------------------

function get_operator_name()
// GUI to read operator name
// A list of predifined names is proposed. 
// If none is selected a tab allows to enter a text
{
    OperatorTab = ["", "Ken", "David", "Odile", "Laurent", "Yann"]
    OperatorId = getItem("Please, select the operator name:", OperatorTab)
    if (OperatorId == -1) {
        Operator_name = getText("Please, type the operator name:", "")
    } else {
        Operator_name = OperatorTab[OperatorId]
    }
    return (Operator_name)
}

function get_session_name()
// GUI to read a text which will be used as the session name
{
    session_name = getText("Please, type the session name:", "Default_session_name");
    return (session_name);
}

function maDate()
// Returns the date using the format : yearmonthday_hourminutesecond
{
    d = new Date();
    Now_date = d.getFullYear() + (("00" + (d.getMonth() + 1).toString()).slice(-2)) + (("00" + (d.getDate()).toString()).slice(-2)) + "_" + (("00" + (d.getHours()).toString()).slice(-2)) + (("00" + (d.getMinutes()).toString()).slice(-2)) + (("00" + (d.getSeconds()).toString()).slice(-2));
    return Now_date;
}



//---------------------------------------------------------------------------------------