// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                   fpasim_tools.dscript
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference    
// -------------------------------------------------------------------------------------------------------------
//    @details                
//
// -------------------------------------------------------------------------------------------------------------
include("./fpasim/display.dscript")
// const FPASIM_ADDR_WIREOUT = {};
// FPASIM_ADDR_WIREOUT['CTRL'] = 0x20; // 0
// FPASIM_ADDR_WIREOUT['MAKE_PULSE'] = 0x21; // 1
// FPASIM_ADDR_WIREOUT['FPASIM_GAIN'] = 0x22; // 2
// FPASIM_ADDR_WIREOUT['MUX_SQ_FB_DELAY'] = 0x23; // 3
// FPASIM_ADDR_WIREOUT['AMP_SQ_OF_DELAY'] = 0x24; // 4
// FPASIM_ADDR_WIREOUT['ERROR_DELAY'] = 0x25; // 5
// FPASIM_ADDR_WIREOUT['RA_DELAY'] = 0x26; // 6
// FPASIM_ADDR_WIREOUT['TES_CONF'] = 0x27; // 7
// // FPASIM_ADDR_WIREOUT['RFU'] = 0x28; // 8
// // FPASIM_ADDR_WIREOUT['RFU'] = 0x29; // 9
// // FPASIM_ADDR_WIREOUT['RFU'] = 0x2A; // 10
// FPASIM_ADDR_WIREOUT['DATA_COUNT'] = 0x2B; // 11
// FPASIM_ADDR_WIREOUT['REC_CTRL'] = 0x2C; // 12
// FPASIM_ADDR_WIREOUT['REC_CONF0'] = 0x2D; // 13
// // FPASIM_ADDR_WIREOUT['RFU'] = 0x2E; // 14
// // FPASIM_ADDR_WIREOUT['RFU'] = 0x2F; // 15
// // FPASIM_ADDR_WIREOUT['RFU'] = 0x30; // 16
// FPASIM_ADDR_WIREOUT['REC_DATA_COUNT'] = 0x31; // 17
// FPASIM_ADDR_WIREOUT['SPI_CTRL'] = 0x32; // 18
// FPASIM_ADDR_WIREOUT['SPI_CONF'] = 0x33; // 19
// FPASIM_ADDR_WIREOUT['SPI_WR_DATA'] = 0x34; // 20
// FPASIM_ADDR_WIREOUT['SPI_RD_DATA'] = 0x35; // 21
// FPASIM_ADDR_WIREOUT['SPI_STATUS'] = 0x36; // 22
// // FPASIM_ADDR_WIREOUT['RFU'] = 0x37; // 23
// FPASIM_ADDR_WIREOUT['DEBUG_CTRL'] = 0x38; // 24
// FPASIM_ADDR_WIREOUT['ERROR_SEL'] = 0x39; // 25
// FPASIM_ADDR_WIREOUT['ERRORS'] = 0x3A; // 26
// FPASIM_ADDR_WIREOUT['STATUS'] = 0x3B; // 27
// // FPASIM_ADDR_WIREOUT['RFU'] = 0x3C; // 28
// FPASIM_ADDR_WIREOUT['BOARD_ID'] = 0x3D; // 29
// FPASIM_ADDR_WIREOUT['FIRMWARE_ID'] = 0x3E; // 30
// FPASIM_ADDR_WIREOUT['FIRMWARE_VERSION'] = 0x3F; // 31

 /**
    * Get a specific wireout values
    * @param {string} reg_name_p - register name
    * @param {number} level_p - level of indentation at the beginning
    * @param {number} mode_p - define the print output
    * @param {number} verbosity_p - level of verbosity
    * @return {object} dic.data - data value (all read bits)
    * @return {object} dic.error - error value
    * @return {object} dic.field_name(s) - (optional) value(s) of the differents fields, if exist
    */  
function get_fpasim_wireout(reg_name_p,level_p,mode_p,verbosity_p)
{
    // default function parameter values
    if (typeof(level_p)==='undefined') level_p = 0;
    if (typeof(mode_p)==='undefined') mode_p = 0;
    if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

    level0 = level_p;
    level1 = level_p + 1;


    // get the wireout values
    getLatestValue("FPA_WireOutValues");

    msg_field = '';
    error = 0;
    data = 0;
    dic = {};
    switch(reg_name_p) {
    case 'CTRL':
            data = FPA_WireOutValues[0];
            en = (data & 0x1);
            rst = ((data >> 1) & 0x1);
            msg_field = [
                    'en: 0x'+convert_int_to_str_hex(value_p=en,width_p=1),
                    'rst: 0x'+convert_int_to_str_hex(value_p=rst,width_p=1)
                    ];
            break;
    case 'MAKE_PULSE':
        data = FPA_WireOutValues[1];
        pulse_height = (data & 0x7FF);
        time_shift = ( (data >> 16) & 0xF);
        pixel_id = ( (data >> 24) & 0x3F);
        pixel_all = ( (data >> 31) & 0x1);
        msg_field = [
                'pulse_height: 0x' + convert_int_to_str_hex(value_p=pulse_height,width_p=11),
                'time_shift: 0x'   + convert_int_to_str_hex(value_p=time_shift,width_p=4),
                'pixel_id: 0x'     + convert_int_to_str_hex(value_p=pixel_id,width_p=6),
                'pixel_all: 0x'    + convert_int_to_str_hex(value_p=pixel_all,width_p=1)
                ];
        break;
    case 'FPASIM_GAIN':
        data = FPA_WireOutValues[2];
        gain = (data & 0x3);
        print('bobi');
        msg_field = [
                'gain: 0x' + convert_int_to_str_hex(value_p=gain,width_p=3)
                ];
        break;
    case 'MUX_SQ_FB_DELAY':
        data = FPA_WireOutValues[3];
        delay = (data & 0x3F);
        msg_field = [
                'delay: 0x' + convert_int_to_str_hex(value_p=delay,width_p=6)
                ];
        break;
    case 'AMP_SQ_OF_DELAY':
        data = FPA_WireOutValues[4];
        delay = (data & 0x3F);
        msg_field = [
                'delay: 0x' + convert_int_to_str_hex(value_p=delay,width_p=6)
                ];
        break;
    case 'ERROR_DELAY':
        data = FPA_WireOutValues[5];
        delay = (data & 0x3F);
        msg_field = [
                'delay: 0x' + convert_int_to_str_hex(value_p=delay,width_p=6)
                ];
        break;
    case 'RA_DELAY':
        data = FPA_WireOutValues[6];
        delay = (data & 0x3F);
        msg_field = [
                'delay: 0x' + convert_int_to_str_hex(value_p=delay,width_p=6)
                ];
        break;
    case 'TES_CONF':
        data = FPA_WireOutValues[7];
        nb_sample_by_frame = (data & 0x1FFF);
        nb_sample_by_pixel = ((data >> 16) & 0x7F);
        nb_pixel_by_frame = ((data >> 24) & 0x3F);
        msg_field = [
                'nb_sample_by_frame: 0x' + convert_int_to_str_hex(value_p=nb_sample_by_frame,width_p=13),
                'nb_sample_by_pixel: 0x' + convert_int_to_str_hex(value_p=nb_sample_by_pixel,width_p=7),
                'nb_pixel_by_frame: 0x' + convert_int_to_str_hex(value_p=nb_pixel_by_frame,width_p=6)
                ];
        break;

      // case 'RFU':
      //   data = FPA_WireOutValues[8];
      //   break;

      // case 'RFU':
      //   data = FPA_WireOutValues[9];
      //   break;

      // case 'RFU':
      //   data = FPA_WireOutValues[10];
      //   break;

    case 'DATA_COUNT':
        data = FPA_WireOutValues[11];
        pipe_data_count = (data & 0xFFFF);
        make_pulse_wr_data_count = ((data >> 16) & 0xFFFF);
        msg_field = [
                'pipe_data_count: 0x' + convert_int_to_str_hex(value_p=pipe_data_count,width_p=16),
                'make_pulse_wr_data_count: 0x' + convert_int_to_str_hex(value_p=make_pulse_wr_data_count,width_p=16)
                ];
        break;
    case 'REC_CTRL':
        data = FPA_WireOutValues[12];
        rec_adc_nb_word_32b = (data & 0xFFFF);
        msg_field = [
                'rec_adc_nb_word_32b: 0x' + convert_int_to_str_hex(value_p=rec_adc_nb_word_32b,width_p=16)
                ];
        break;
    case 'REC_CONF0':
        data = FPA_WireOutValues[13];
        rec_adc_en = (data & 0x1);
        msg_field = [
                'rec_adc_en: 0x' + convert_int_to_str_hex(value_p=rec_adc_en,width_p=1)
                ];
        break;

       // case 'RFU':
      //   data = FPA_WireOutValues[14];
      //   break;

      // case 'RFU':
      //   data = FPA_WireOutValues[15];
      //   break;

      // case 'RFU':
      //   data = FPA_WireOutValues[16];
      //   break;

    case 'REC_DATA_COUNT':
        data = FPA_WireOutValues[17];
        rec_adc_data_count = (data & 0xFFFF);
        msg_field = [
                'rec_adc_data_count: 0x' + convert_int_to_str_hex(value_p=rec_adc_data_count,width_p=16)
                ];
        break;
    case 'SPI_CTRL':
        data = FPA_WireOutValues[18];
        en = (data & 0x1);
        rst = ((data >> 1) & 0x1);
        msg_field = [
                'en: 0x' + convert_int_to_str_hex(value_p=en,width_p=1),
                'rst: 0x' + convert_int_to_str_hex(value_p=rst,width_p=1)
                ];
        break;
    case 'SPI_CONF':
        data = FPA_WireOutValues[19];
        spi_mode = (data & 0x1);
        spi_id = ((data >> 4) & 0x7);
        spi_dac_tx_enable = ((data >> 8) & 0x1);
        msg_field = [
                'spi_mode: 0x' + convert_int_to_str_hex(value_p=spi_mode,width_p=1),
                'spi_id: 0x' + convert_int_to_str_hex(value_p=spi_id,width_p=3),
                'spi_dac_tx_enable: 0x' + convert_int_to_str_hex(value_p=spi_dac_tx_enable,width_p=1)
                ];
        break;
    case 'SPI_WR_DATA':
        data = FPA_WireOutValues[20];
        msg_field = [
                'data: 0x' + convert_int_to_str_hex(value_p=data,width_p=32)
                ];
        break;
    case 'SPI_RD_DATA':
        data = FPA_WireOutValues[21];
        msg_field = [
                'data: 0x' + convert_int_to_str_hex(value_p=data,width_p=32)
                ];
        break;
    case 'SPI_STATUS':
        data = FPA_WireOutValues[22];
        spi_ready = (data & 0x1);
        cdce_pll_status = ((data >> 4) & 0x1);
        amc_galr_n = ((data >> 8) & 0x1);
        msg_field = [
                'spi_ready: 0x' + convert_int_to_str_hex(value_p=spi_ready,width_p=1),
                'cdce_pll_status: 0x' + convert_int_to_str_hex(value_p=cdce_pll_status,width_p=1),
                'amc_galr_n: 0x' + convert_int_to_str_hex(value_p=amc_galr_n,width_p=1)
                ];
        break;

        // case 'RFU':
        // data = FPA_WireOutValues[23];
        // break;

    case 'DEBUG_CTRL':
        data = FPA_WireOutValues[24];
        debug_pulse = (data & 0x1);
        rst_status = ((data >> 1) & 0x1);
        msg_field = [
                'debug_pulse: 0x' + convert_int_to_str_hex(value_p=debug_pulse,width_p=1),
                'rst_status: 0x' + convert_int_to_str_hex(value_p=rst_status,width_p=1)
                ];
        break;

    case 'ERROR_SEL':
        data = FPA_WireOutValues[25];
        sel_errors = (data & 0xF);
        msg_field = [
                'sel_errors: 0x' + convert_int_to_str_hex(value_p=sel_errors,width_p=4)
                ];
        break;

    case 'ERRORS':
        data = FPA_WireOutValues[26];
        errors = (data);
        msg_field = [
                'errors: 0x' + convert_int_to_str_hex(value_p=errors,width_p=32)
                ];
        break;

    case 'STATUS':
        data = FPA_WireOutValues[27];
        status = (data);
        msg_field = [
                'status: 0x' + convert_int_to_str_hex(value_p=status,width_p=32)
                ];
        break;

        // case 'RFU':
        // data = FPA_WireOutValues[28];
        // break;

    case 'BOARD_ID':
        data = FPA_WireOutValues[29];
        msg_field = [
                '0x'+convert_int_to_str_hex(value_p=data,width_p=32)
                ];
        break;
    case 'FIRMWARE_ID':
        data = FPA_WireOutValues[30];
        msg_field = [
                convert_hex_to_ascii(value_p=data,width_p=32)
                ];
        break;
    case 'FIRMWARE_VERSION':
        data = FPA_WireOutValues[31];
        msg_field = [
                '0x'+convert_int_to_str_hex(value_p=data,width_p=32)
                ];
        break;
    default:
        msg = "[get_fpasim_wireout]: Error" + reg_name_p + " doesn't exist."
        display_error(msg_p=msg, level_p=level0, mode_p=mode_p);
        error = 1;
        break;
    }


    dic['data'] = data;
    dic['error'] = error;

    /*
        print field values
    */
    if (verbosity_p > 0)
    {
        display(msg_p=msg_field, level_p=level0, mode_p=mode_p);
    }

    return dic;


}

function check_equal(value0_p,value1_p,msg_error_p, level_p,mode_p)
{
    // default function parameter values
    if (typeof(level_p)==='undefined') level_p = 0;
    if (typeof(mode_p)==='undefined') mode_p = 0;
    level0 = level_p;
    level1 = level_p + 1;

    if (value0_p !== value1_p)
    {
        // display_error(msg_p=msg_error_p, level_p=level0, mode_p=mode_p);
        // print("value0: ", value0_p);
        // print("value1: ",value1_p);
        msg = [
          "[Error]: value0_p != value1_p",
          "[check_equal]: value0_p: 0x" + convert_int_to_str_hex(value_p=value0_p,width_p=32),
          "[check_equal]: value1_p: 0x" + convert_int_to_str_hex(value_p=value1_p,width_p=32)
        ];
        display(msg_p=msg,level_p=level1,mode_p=mode_p);
    }
}

//---------------------------------------------------------------------------------------
// General functions
//---------------------------------------------------------------------------------------

function get_operator_name()
// GUI to read operator name
// A list of predifined names is proposed. 
// If none is selected a tab allows to enter a text
{
    OperatorTab = ["", "Ken", "David", "Odile", "Laurent", "Yann"]
    OperatorId = getItem("Please, select the operator name:", OperatorTab)
    if (OperatorId == -1)
        {
            Operator_name = getText("Please, type the operator name:", "")
        }
    else
        {
            Operator_name = OperatorTab[OperatorId]
        }
    return(Operator_name)
}

function get_session_name()
// GUI to read a text which will be used as the session name
{
    session_name = getText("Please, type the session name:", "Default_session_name");
    return(session_name);
}

function maDate()
// Returns the date using the format : yearmonthday_hourminutesecond
{
    d = new Date();
    Now_date = d.getFullYear()+(("00" +(d.getMonth()+1).toString()).slice(-2))+(("00" +(d.getDate()).toString()).slice(-2))+"_"+(("00" +(d.getHours()).toString()).slice(-2))+(("00" +(d.getMinutes()).toString()).slice(-2))+(("00" +(d.getSeconds()).toString()).slice(-2));
    return Now_date;
}

/**
 * Convert a integer to string (hexadecimal representation). The result is zero padded to match the width_p parameters
 * @param {number} value_p - integer value to convert
 * @param {number} width_p - value bus width (expressed in bits)
 * @return {string} string hexadecimal value
 */
function convert_int_to_str_hex(value_p,width_p)
{
    // default function parameter values
    if (typeof(width_p)==='undefined') width_p = 32;

    // compute the number of hex decimal to output
    nb_hex_char = Math.ceil(width_p/4);
    str_hex = value_p.toString(16);
    while(str_hex.length < nb_hex_char) 
    {
        str_hex = "0" + str_hex;
    }
    return str_hex;

}

/**
 * Convert a hexadecimal code value (integer value) to ASCII string
 * @param {number} value_p - integer value to convert (hexadecimal ascii code)
 * @param {number} width_p - value bus width (expressed in bits)
 * @return {string} ASCII characters
 */
function convert_hex_to_ascii(value_p,width_p)
{
    // default function parameter values
    if (typeof(width_p)==='undefined') width_p = 32;

    // compute the number bytes
    nb_bytes = Math.ceil(width_p/8);
    str0 = '';
    for(i=0;i<nb_bytes;i++)
    {
        value_tmp = (0xFF) & (value_p >> (8*i));
        str0 = String.fromCharCode(value_tmp) + str0;
    }
    return str0;

}

//---------------------------------------------------------------------------------------