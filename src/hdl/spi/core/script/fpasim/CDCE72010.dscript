// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                    CDCE72010.dscript
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference
// -------------------------------------------------------------------------------------------------------------
//    @details
//
//    This javscript generates spi commands in order to initialize the cdce72010 registers.
//
//    Note:
//       . Tested with javascript
//
// -------------------------------------------------------------------------------------------------------------

// import libraries
include("./fpasim/display.dscript");
include("./fpasim/fpasim_address.dscript");


const CDCE_ADDR = {};
CDCE_ADDR['reg0'] = 0x00;
CDCE_ADDR['reg1'] = 0x01;
CDCE_ADDR['reg2'] = 0x02;
CDCE_ADDR['reg3'] = 0x03;
CDCE_ADDR['reg4'] = 0x04;
CDCE_ADDR['reg5'] = 0x05;
CDCE_ADDR['reg6'] = 0x06;
CDCE_ADDR['reg7'] = 0x07;
CDCE_ADDR['reg8'] = 0x08;
CDCE_ADDR['reg9'] = 0x09;
CDCE_ADDR['reg10'] = 0x0A;
CDCE_ADDR['reg11'] = 0x0B;
CDCE_ADDR['reg12'] = 0x0C;

/**
  This function reverse the bit orders.
  width_p  | value_p            | result            |
  ---------|--------------------|-------------------|
  4        | 1 ("0001")         | 8 ("1000")        |
  4        | 3 ("0011")         | 12 ("1100")       |
  4        | 3 ("0111")         | 14 ("1110")       |
  5        | 1 ("00001")        | 16 ("10000")      |

  * @param {number} value_p - value where to reverse bit
  * @param {number} width_p - width of the input value (expressed in bits)
  * @return {number} value with the bit reverse

*/
function reverse_bit_order(value_p,width_p)
{
  res = 0;
  bit_max_pos = width_p - 1;
    for (i = 0; i<width_p;i++)
  {
        // get bit value (LSB first)
        value = (value_p >> i) & 0x1;
        res = res + value*Math.pow(2,bit_max_pos - i);
  }

    return res;

}


    /*
    FPGA specifics:
     Initialize the spi links
    */    
    function cdce_init_device()
    {
        //---------------------------------------------------------------------
        //-- write in the SPI_CTRL register 
        //---------------------------------------------------------------------

        // reset the spi links
        // rst = 1;
        // en = 0;
        // data = (rst << 1) + en;
        // sendToFPA_debugSetWireIn(0x12,data);

        //---------------------------------------------------------------------
        //-- write in the SPI_CTRL register 
        //---------------------------------------------------------------------
        
        // en the spi links
        rst = 0;
        en = 1;
        data = (rst << 1) + en;
        addr = FPASIM_ADDR_WIREIN['SPI_CTRL'];
        sendToFPA_debugSetWireIn(addr ,data);
    }

    /**
    * FPGA specifics: 
        Build the expected spi command
        Build the expected fpga register accesses
    */
    function cdce_write_command(addr_p,data_p)
      {

        //---------------------------------------------------------------------
        // write in the SPI_CONF register
        //---------------------------------------------------------------------
        mode = 1; // 0: rd, 1: wr
        spi_id = 0; // 0: cdce,1: adc, 2: dac, 3: amc
        spi_dac_tx_enable = 0;
        data = (spi_dac_tx_enable << 8) + (spi_id << 4) + mode;
        addr = FPASIM_ADDR_WIREIN['SPI_CONF'];
        sendToFPA_debugSetWireIn(addr,data);

        //---------------------------------------------------------------------
        // build the SPI commands
        //    (see cdce72010 datasheet) 
        //---------------------------------------------------------------------
        // bit27 bit26 ... bit0 addr3 .. addr0 
        spi_cmd = (data_p << 4) + addr_p;

        // reverse bit order:
        // addr0 addr1 .... bit0 ... bit26 bit27
        spi_cmd = reverse_bit_order(value_p=spi_cmd,width_p=32);
        addr = FPASIM_ADDR_WIREIN['SPI_WR_DATA'];
        //---------------------------------------------------------------------
        // write in the SPI_WR_DATA register
        //---------------------------------------------------------------------
        sendToFPA_debugSetWireIn(addr,spi_cmd);

        //---------------------------------------------------------------------
        // write in the TRIG register
        //  => activate the spi_valid bit
        //---------------------------------------------------------------------
        addr = FPASIM_ADDR_TRIGIN['TRIG'];
        pos =  FPASIM_POS_TRIGIN['spi_valid'];
        sendToFPA_debugSetTriggerIn(addr,pos);
        waitMs(100);

      }

      function cdce_read_command(addr_p)
      {

        //---------------------------------------------------------------------
        // write in the SPI_CONF register
        //---------------------------------------------------------------------
        mode = 0; // 0: rd, 1: wr
        spi_id = 0; // 0: cdce,1: adc, 2: dac, 3: amc
        spi_dac_tx_enable = 0;
        data = (spi_dac_tx_enable << 8) + (spi_id << 4) + mode;
        addr = FPASIM_ADDR_WIREIN['SPI_CONF'];
        sendToFPA_debugSetWireIn(addr,data);

        //---------------------------------------------------------------------
        // First access
        //  build the read command
        //     (see cdce72010 datasheet) 
        //---------------------------------------------------------------------
        // 0 .... 0 A A A A  1 1 1 0 
		mask = 0xF;
        data = (addr_p & mask);
        addr = parseInt('1110',2);
        spi_cmd = (data << 4) + addr;

        // reverse bit order:
        // addr0 addr1 .... bit0 ... bit26 bit27
        spi_cmd = reverse_bit_order(value_p=spi_cmd,width_p=32);
		
		print('data',data);
		print('addr',addr);
		print('spi_cmd',spi_cmd);
		tmp = getText("Send the READ command", "");

        // write in the SPI_WR_DATA register
        //---------------------------------------------------------------------
        addr = FPASIM_ADDR_WIREIN['SPI_WR_DATA'];
        sendToFPA_debugSetWireIn(addr,spi_cmd);

        // write in the TRIG register
        //  => activate the spi_valid bit
        //---------------------------------------------------------------------
        addr = FPASIM_ADDR_TRIGIN['TRIG'];
        pos =  FPASIM_POS_TRIGIN['spi_valid'];
        sendToFPA_debugSetTriggerIn(addr,pos);
        waitMs(100);



        //---------------------------------------------------------------------
        // Second access
        //  get the read data
        //    (see cdce72010 datasheet) 
        //---------------------------------------------------------------------
        // bit27 bit26 ... bit0 addr3 .. addr0 
        data = 0x0000000;
		addr = 0x0;
		//addr = addr_p;
        spi_cmd = (data << 4) + addr;
		//data = 0x0;
		//addr = parseInt('1110',2);
        //spi_cmd = (data << 4) + addr;
		
		//mask = 0xF;
        //data = (addr_p & mask);
        //addr = parseInt('1110',2);
        //spi_cmd = (data << 4) + addr;


        // reverse bit order:
        // addr0 addr1 .... bit0 ... bit26 bit27
        spi_cmd = reverse_bit_order(value_p=spi_cmd,width_p=32);
		tmp = getText("Send the READ dummy word", "");
        //---------------------------------------------------------------------
        // write in the SPI_WR_DATA register
        //---------------------------------------------------------------------
        addr = FPASIM_ADDR_WIREIN['SPI_WR_DATA'];
        sendToFPA_debugSetWireIn(addr,spi_cmd);

        //---------------------------------------------------------------------
        // write in the TRIG register
        //  => activate the spi_valid bit
        //---------------------------------------------------------------------
        addr = FPASIM_ADDR_TRIGIN['TRIG'];
        pos =  FPASIM_POS_TRIGIN['spi_valid'];
        sendToFPA_debugSetTriggerIn(addr,pos);
        waitMs(100);

        //---------------------------------------------------------------------
        // Read wire out registers
        //---------------------------------------------------------------------
        getLatestValue("FPA_WireOutValues");

        return FPA_WireOutValues[21];

      }

    /*
      ###############################################################
       set the config0 register
      ###############################################################
       [27:26]: R/W: outbufsel0yx[1:0]
       [25:24]: R/W: cmosmode0nyx[1:0]
       [23:22]: R/W: cmosmode0pyx[1:0]
       [21]: R/W: pecl0hiswing[0]
       [20]: R/W: irefres[0]
       [17:14]: R/W: icp[3:0]
       [13]: R/W: cp_pre[0]
       [12]: R/W: cp_opa[0]
       [11]: R/W: cp_snk[0]
       [10]: R/W: cp_src[0]
       [9]: R/W: cp_dir[0]
       [7:6]: R/W: delay_pfd[1:0]
       [5]: R/W: refselcntrl[0]
       [4]: R/W: vcxosel[0]
       [3]: R/W: secsel[0]
       [2]: R/W: prisel[0]
       [1:0]: R/W: inbufselyx[1:0]
    */
    function cdce_set_config0(
                    outbufsel0yx_p,cmosmode0nyx_p,
                    cmosmode0pyx_p,pecl0hiswing_p,irefres_p,
                    icp_p,cp_pre_p, cp_opa_p,
                    cp_snk_p,cp_src_p,cp_dir_p,
                    delay_pfd_p,refselcntrl_p,vcxosel_p,
                    secsel_p,prisel_p,inbufselyx_p
             
                    )
        {

            cmt = 'config0';
            reserved = 0;
            value5 = (outbufsel0yx_p << 26 ) + (cmosmode0nyx_p << 24);
            value4 = (cmosmode0pyx_p << 22) + (pecl0hiswing_p << 21) + (irefres_p<<20);
            value3 = (icp_p << 14) + (cp_pre_p << 13) + (cp_opa_p << 12);
            value2 = (cp_snk_p << 11) + (cp_src_p << 10) + (cp_dir_p << 9);
            value1 = (delay_pfd_p << 6) + (refselcntrl_p << 5) + (vcxosel_p << 4);
            value0 = (secsel_p << 3) + (prisel_p << 2) + (inbufselyx_p << 0);

            value =  value5 + value4 + value3 + value2 + value1 + value0;

            addr = CDCE_ADDR['reg0'];
            cdce_write_command(addr_p=addr,data_p=value);
        }
    /*
     ###############################################################
      Set the config1 register
     ###############################################################
      [27:26]: R/W: outbufsel1yx_p[1:0]
      [25:24]: R/W: cmosmode1nyx_p[1:0]
      [23:22]: R/W: cmosmode1pyx_p[1:0]
      [21]: R/W: pecl1hiswing_p[0]
      [20]: R/W: en01div_p[0]
      [19:13]: R/W: out1divrsel_p[6:0]
      [12:6]: R/W: ph1adjc_p[6:0]
      [5]: R/W: failsafe[0]
      [4]: R/W: secinvbb[0]
      [3]: R/W: priinvbb[0]
      [2]: R/W: termsel[0]
      [1]: R/W: hysten[0]
      [0]: R/W: acdcsel[0]
    */
    function cdce_set_config1(
                    outbufsel1yx_p,cmosmode1nyx_p,
                    cmosmode1pyx_p,pecl1hiswing_p,en01div_p, 
                    out1divrsel_p, ph1adjc_p,
                    failsafe_p,secinvbb_p,
                    priinvbb_p,termsel_p,hysten_p,acdcsel_p
                    )
        {

            cmt = 'config1';
            reserved = 0;
            value4 = (outbufsel1yx_p << 26 ) + (cmosmode1nyx_p << 24);
            value3 = (cmosmode1pyx_p << 22) + (pecl1hiswing_p << 21) + (en01div_p << 20); 
            value2 = (out1divrsel_p << 13) + (ph1adjc_p << 6);
            value1 = (failsafe_p << 5) + (secinvbb_p << 4);
            value0 = (priinvbb_p << 3) + (termsel_p << 2) + (hysten_p << 1) + (acdcsel_p << 0);

            value = value4 + value3 + value2 + value1 + value0;

            addr = CDCE_ADDR['reg1'];
            cdce_write_command(addr_p=addr,data_p=value);
        }

    /*
     ###############################################################
      Set the config2 register
     ###############################################################
      [27:26]: R/W: outbufsel2yx[1:0]
      [25:24]: R/W: cmosmode2nyx[1:0]
      [23:22]: R/W: cmosmode2pyx[1:0]
      [21]: R/W: pecl2hiswing[0]
      [20]: R/W: en2div[0]
      [19:13]: R/W: out2divrsel[6:0]
      [12:6]: R/W: ph2adjc[6:0]
      [5:3]: R/W: dlyn[2:0]
      [2:0]: R/W: dlym[2:0]
    */
    function cdce_set_config2(
                    outbufsel2yx_p,cmosmode2nyx_p,
                    cmosmode2pyx_p,pecl2hiswing_p,en2div_p, 
                    out2divrsel_p, ph2adjc_p,
                    dlyn_p,dlym_p
                    )
        {

            cmt = 'config2';
            reserved = 0;
            value3 = (outbufsel2yx_p << 26 ) + (cmosmode2nyx_p << 24);
            value2 = (cmosmode2pyx_p << 22) + (pecl2hiswing_p << 21) + (en2div_p << 20);
            value1 = (out2divrsel_p << 13) + (ph2adjc_p << 6);
            value0 = (dlyn_p << 3) + (dlym_p << 0);

            value = value3 + value2 + value1 + value0;

            addr = CDCE_ADDR['reg2'];
            cdce_write_command(addr_p=addr,data_p=value);
        }

    /*
     ###############################################################
      set the config3 register
     ###############################################################
      [27:26]: R/W: outbufsel3yx[1:0]
      [25:24]: R/W: cmosmode3nyx[1:0]
      [23:22]: R/W: cmosmode3pyx[1:0]
      [21]: R/W: pecl3hiswing[0]
      [20]: R/W: en3div[0]
      [19:13]: R/W: out3divrsel[6:0]
      [12:6]: R/W: ph3adjc[6:0]
      [5:4]: R/W: bias_div23[1:0]
      [3:2]: R/W: bias_div01[1:0]
      [1]: R/W: dis_fdet_fb[0]
      [0]: R/W: dis_fdet_ref[0]
    */
    function cdce_set_config3(
                    outbufsel3yx_p,cmosmode3nyx_p,
                    cmosmode3pyx_p,pecl3hiswing_p,en3div_p, 
                    out3divrsel_p, ph3adjc_p,
                    bias_div23_p,
                    bias_div01_p, dis_fdet_fb_p,dis_fdet_ref_p
                    )
        {

            cmt = 'config3';
            reserved = 0;
            value4 = (outbufsel3yx_p << 26 ) + (cmosmode3nyx_p << 24);
            value3 = (cmosmode3pyx_p << 22) + (pecl3hiswing_p << 21) + (en3div_p << 20);
            value2 = (out3divrsel_p << 13) + (ph3adjc_p << 6);
            value1 = (bias_div23_p << 4);
            value0 = (bias_div01_p << 2) + (dis_fdet_fb_p << 1) + (dis_fdet_ref_p << 0);

            value = value4 + value3 + value2 + value1 + value0;

            addr = CDCE_ADDR['reg3'];
            cdce_write_command(addr_p=addr,data_p=value);
       }

    /*
     ###############################################################
      Set the config4 register
     ###############################################################
      [27:26]: R/W: outbufsel4yx[1:0]
      [25:24]: R/W: cmosmode4nyx[1:0]
      [23:22]: R/W: cmosmode4pyx[1:0]
      [21]: R/W: pecl4hiswing[0]
      [20]: R/W: en4div[0]
      [19:13]: R/W: out4divrsel[6:0]
      [12:6]: R/W: ph4adjc[6:0]
      [4]: R/W: holdonlor[0]
    */
    function cdce_set_config4(
                    outbufsel4yx_p,cmosmode4nyx_p,
                    cmosmode4pyx_p,pecl4hiswing_p,en4div_p, 
                    out4divrsel_p, ph4adjc_p,
                    holdonlor_p
                    )
       {

            cmt = 'config4';
            reserved = 0;
            value3 = (outbufsel4yx_p << 26 ) + (cmosmode4nyx_p << 24);
            value2 = (cmosmode4pyx_p << 22) + (pecl4hiswing_p << 21) + (en4div_p << 20);
            value1 = (out4divrsel_p << 13) + (ph4adjc_p << 6);
            value0 = (holdonlor_p << 4);

            value =  value3 + value2 + value1 + value0;

            addr = CDCE_ADDR['reg4'];
            cdce_write_command(addr_p=addr,data_p=value);

        }
    /*
    ###############################################################
     Set the config5 register
    ###############################################################
     [27:26]: R/W: outbufsel5yx[1:0]
     [25:24]: R/W: cmosmode5nyx[1:0]
     [23:22]: R/W: cmosmode5pyx[1:0]
     [21]: R/W: pecl5hiswing[0]
     [20]: R/W: en5div[0]
     [19:13]: R/W: out5divrsel[6:0]
     [12:6]: R/W: ph5adjc[6:0]
     [3:2]: R/W: bias_div67[1:0]
     [1:0]: R/W: bias_div45[1:0]
    */
    function cdce_set_config5(
                    outbufsel5yx_p,cmosmode5nyx_p,
                    cmosmode5pyx_p,pecl5hiswing_p,en5div_p, 
                    out5divrsel_p, ph5adjc_p,
                    bias_div67_p,bias_div45_p
                    )
        {

            cmt = 'config5';
            reserved = 0;
            value3 = (outbufsel5yx_p << 26 ) + (cmosmode5nyx_p << 24);
            value2 = (cmosmode5pyx_p << 22) + (pecl5hiswing_p << 21) + (en5div_p << 20);
            value1 = (out5divrsel_p << 13) + (ph5adjc_p << 6);
            value0 = (bias_div67_p << 2) + (bias_div45_p << 0);

            value =  value3 + value2 + value1 + value0;

            addr = CDCE_ADDR['reg5'];
            cdce_write_command(addr_p=addr,data_p=value);
        }

    /*
     ###############################################################
      Set the config6 register
     ###############################################################
      [27:26]: R/W: outbufsel6yx[1:0]
      [25:24]: R/W: cmosmode6nyx[1:0]
      [23:22]: R/W: cmosmode6pyx[1:0]
      [21]: R/W: pecl6hiswing[0]
      [20]: R/W: en6div[0]
      [19:13]: R/W: out6divrsel[6:0]
      [12:6]: R/W: ph6adjc[6:0]
      [5]: R/W: det_start_bypass[0]
      [4]: R/W: fb_start_bypass[0]
      [3]: R/W: fbdeterm_div2_dis[0]
      [2]: R/W: fbdeterm_div_sel[0]
      [0]: R/W: fb_fd_desel[0]
    */

    function cdce_set_config6(
                    outbufsel6yx_p,cmosmode6nyx_p,
                    cmosmode6pyx_p,pecl6hiswing_p,en6div_p, 
                    out6divrsel_p, ph6adjc_p,
                    det_start_bypass_p,fb_start_bypass_p,
                    fbdeterm_div2_dis_p,fbdeterm_div_sel_p,fb_fd_desel_p
                    )
        {


            cmt = 'config6';
            reserved = 0;
            value4 = (outbufsel6yx_p << 26 ) + (cmosmode6nyx_p << 24);
            value3 = (cmosmode6pyx_p << 22) + (pecl6hiswing_p << 21) + (en6div_p << 20);
            value2 = (out6divrsel_p << 13) + (ph6adjc_p << 6);
            value1 = (det_start_bypass_p << 5) + (fb_start_bypass_p << 4);
            value0 = (fbdeterm_div2_dis_p << 3) + (fbdeterm_div_sel_p << 2) + (fb_fd_desel_p << 0 );

            value = value4 + value3 + value2 + value1 + value0;

            addr = CDCE_ADDR['reg6'];
            cdce_write_command(addr_p=addr,data_p=value);
        }

    /*
      ###############################################################
       Set the config7 register
      ###############################################################
       [27:26]: R/W: outbufsel7yx[1:0]
       [25:24]: R/W: cmosmode7nyx[1:0]
       [23:22]: R/W: cmosmode7pyx[1:0]
       [21]: R/W: pecl7hiswing[0]
       [20]: R/W: en7div[0]
       [19:13]: R/W: out7divrsel[6:0]
       [12:6]: R/W: ph7adjc[6:0]
       [5]: R/W: adlock[0]
       [4:3]: R/W: lockc[1:0]
       [1:0]: R/W: lockw[1:0]
    */
    function cdce_set_config7(
                    outbufsel7yx_p,cmosmode7nyx_p,
                    cmosmode7pyx_p,pecl7hiswing_p,en7div_p, 
                    out7divrsel_p, ph7adjc_p,
                    adlock_p,lockc_p, lockw_p
                    )
        {

            cmt = 'config7';
            reserved = 0;
            value3 = (outbufsel7yx_p << 26 ) + (cmosmode7nyx_p << 24);
            value2 = (cmosmode7pyx_p << 22) + (pecl7hiswing_p << 21) + (en7div_p << 20);
            value1 = (out7divrsel_p << 13) + (ph7adjc_p << 6);
            value0 = (adlock_p << 5) + (lockc_p << 3) + lockw_p;

            value = value3 + value2 + value1 + value0;

           addr = CDCE_ADDR['reg7'];
            cdce_write_command(addr_p=addr,data_p=value);
        }

    /*
      ###############################################################
       Set the config8 register
      ###############################################################
       [27:26]: R/W: outbufsel8yx[1:0]
       [25:24]: R/W: cmosmode8nyx[1:0]
       [23:22]: R/W: cmosmode8pyx[1:0]
       [21]: R/W: pecl8hiswing[0]
       [20]: R/W: en8div[0]
       [19:13]: R/W: out8divrsel[6:0]
       [12:6]: R/W: ph8adjc[6:0]
       [5]: R/W: vcxoinvbb[0]
       [4]: R/W: vcxotermsel[0]
       [3]: R/W: vcxohysten[0]
       [2]: R/W: vcxoacdcsel[0]
       [1:0]: R/W: vcxobufselyx[1:0]
    */
    function cdce_set_config8(
                    outbufsel8yx_p,cmosmode8nyx_p,
                    cmosmode8pyx_p,pecl8hiswing_p,en89div_p, 
                    out8divrsel_p, ph8adjc_p,
                    vcxoinvbb_p,vcxotermsel_p,
                    vcxohysten_p,vcxoacdcsel_p,vcxobufselyx_p
                    )
        {


            cmt = 'config8';
            reserved = 0;
            value4 = (outbufsel8yx_p << 26 ) + (cmosmode8nyx_p << 24);
            value3 = (cmosmode8pyx_p << 22) + (pecl8hiswing_p << 21) + (en89div_p << 20);
            value2 = (out8divrsel_p << 13) + (ph8adjc_p << 6);
            value1 = (vcxoinvbb_p << 5) + (vcxotermsel_p << 4);
            value0 = (vcxohysten_p << 3) + (vcxoacdcsel_p << 2) + (vcxobufselyx_p << 0);

            value = value4 + value3 + value2 + value1 + value0;

            addr = CDCE_ADDR['reg8'];
            cdce_write_command(addr_p=addr,data_p=value);
        }

    /*
      ###############################################################
       Set the config9 register
      ###############################################################
       [27:26]: R/W: outbufsel9yx[1:0]
       [25:24]: R/W: cmosmode9nyx[1:0]
       [23:22]: R/W: cmosmode9pyx[1:0]
       [21]: R/W: pecl9hiswing[0]
       [20]: R/W: dis_aux_y9[0]
       [19]: R/W: auxinvbb[0]
       [18:17]: R/W: bias_div89[1:0]
       [16:15]: R/W: bias_div_fb[1:0]
       [14]: R/W: npreset_mdiv[0]
       [13]: R/W: low_fd_fb_en[0]
       [12]: R/W: pll_lock_bp[0]
       [11]: R/W: indet_bp[0]
       [10]: R/W: start_bypass[0]
       [9]: R/W: divsync_dis[0]
       [8]: R/W: noinv_reshol_int[0]
       [7:6]: R/W: lockw32[1:0]
       [5:4]: R/W: hold_cnt[1:0]
       [3]: R/W: holdtr[0]
       [2]: R/W: hold_n[0]
       [0]: R/W: holdf[0]
    */
    function cdce_set_config9(
                    outbufsel9yx_p,cmosmode9nyx_p,
                    cmosmode9pyx_p,pecl9hiswing_p,dis_aux_y9_p, 
                    auxinvbb_p, bias_div89_p,bias_div_fb_p,
                    npreset_mdiv_p,low_fd_fb_en_p,pll_lock_bp_p,
                    indet_bp_p,start_bypass_p,divsync_dis_p,noinv_reshol_int_p,
                    lockw32_p,hold_cnt_p,
                    holdtr_p,hold_n_p,holdf_p
                    )

        {

            cmt = 'config9';
            reserved = 0;
            value6 = (outbufsel9yx_p << 26 ) + (cmosmode9nyx_p << 24);
            value5 = (cmosmode9pyx_p << 22) + (pecl9hiswing_p << 21) + (dis_aux_y9_p << 20);
            value4 = (auxinvbb_p << 19) + (bias_div89_p << 17) + (bias_div_fb_p << 15);
            value3 = (npreset_mdiv_p << 14) + (low_fd_fb_en_p << 13) + (pll_lock_bp_p << 12);
            value2 = (indet_bp_p << 11) + (start_bypass_p << 10) + (divsync_dis_p << 9) + (noinv_reshol_int_p<<8);
            value1 = (lockw32_p << 6) + (hold_cnt_p << 4);
            value0 = (holdtr_p << 3) + (hold_n_p << 2) + holdf_p;
            value = value6 + value5 + value4 + value3 + value2 + value1 + value0;

            addr = CDCE_ADDR['reg9'];
            cdce_write_command(addr_p=addr,data_p=value);
        }

    /*
     ###############################################################
      Set the config10 register
     ###############################################################
      [27:14]: R/W: div_m[13:0]
      [13:0]: R/W: div_n[13:0]
    */
    function cdce_set_config10(
                    div_n_p,div_m_p
                     )
       {

            cmt = 'config10';
            value1 = (div_n_p << 14);
            value0 = (div_m_p << 0);
            value = value1 + value0;

            addr = CDCE_ADDR['reg10'];
            cdce_write_command(addr_p=addr,data_p=value);
       }

    /*
     ###############################################################
      Set the config11 register
     ###############################################################
      [26]: R/W: eplock[0]
      [25]: R/W: reset_hold_mode[0]
      [24]: R/W: sel_del1[0]
      [23]: R/W: nreshape1[0]
      [22]: R/W: fb_sel[0]
      [21]: R/W: out_mux_sel[0]
      [20]: R/W: fb_mux_sel[0]
      [19]: R/W: pd_pll[0]
      [18:12]: R/W: fb_phase[6:0]
      [11:5]: R/W: fb_count32[6:0]
      [4]: R/W: fb_inclk_inv[0]
      [3]: R/W: fb_cml_sel[0]
      [2]: R/W: fb_dis[0]
      [1]: R/W: sec_div2[0]
      [0]: R/W: pri_div2[0]
    */
    function cdce_set_config11(
                    eplock_p,reset_hold_mode_p,sel_del1_p,
                    nreshape1_p, fb_sel_p, out_mux_sel_p, fb_mux_sel_p,
                    pd_pll_p,fb_phase_p,fb_count32_p,fb_inclk_inv_p,
                    fb_cml_sel_p,fb_dis_p,sec_div2_p,pri_div2_p
                     )
        {


            cmt = 'config11';
            reserved = 0;
            value3 = (eplock_p << 26) + (reset_hold_mode_p << 25) + (sel_del1_p << 24);
            value2 = (nreshape1_p << 23) + (fb_sel_p << 22) + (out_mux_sel_p << 21) + (fb_mux_sel_p << 20);
            value1 = (pd_pll_p << 19) + (fb_phase_p << 12) + (fb_count32_p << 5) + (fb_inclk_inv_p << 4);
            value0 = (fb_cml_sel_p << 3) + (fb_dis_p << 2) + (sec_div2_p << 1) + (pri_div2_p << 0);
            value = value3 + value2 + value1 + value0;

            addr = CDCE_ADDR['reg11'];
            cdce_write_command(addr_p=addr,data_p=value);
        }


    /*
     ###############################################################
      Set the config12 register
     ###############################################################
      [26]: R/W: secactivity[0]
      [25]: R/W: priactivity[0]
      [24:21]: R/W: titstcfg[3:0]
      [20:17]: R/W: status[3:0]
      [15]: R/W: shold[0]
      [14]: R/W: sxoiref[0]
      [13]: R/W: pd_io[0]
      [12:10]: R/W: revision[2:0]
      [9]: R/W: gtme[0]
      [8]: R/W: reset_hold_n[0]
      [7]: R/W: sleep[0]
      [6]: R: pll_lock[0]
      [5]: R: indet_vcxo[0]
      [4]: R: indet_aux[0]
    */
    function cdce_set_config12(
                    secactivity_p,priactivity_p,titstcfg_p,
                    status_p,
                    shold_p,sxoiref_p,pd_io_p,
                    revision_p,gtme_p, reset_hold_n_p,
                    sleep_n_p,pll_lock_p,indet_vcxo_p,indet_aux_p
                     )

        {

            cmt = 'config12';
            reserved = 0;
            value4 = (secactivity_p << 26) + (priactivity_p << 25) + (titstcfg_p << 21);
            value3 = (status_p << 17);
            value2 = (shold_p << 15) + (sxoiref_p << 14) + (pd_io_p << 13);
            value1 = (revision_p << 10) + (gtme_p << 9) + (reset_hold_n_p << 8);
            value0 = (sleep_n_p << 7) + (pll_lock_p << 6) + (indet_vcxo_p << 5) + (indet_aux_p << 4);
            value = value4 + value3 + value2 + value1 + value0;

            addr = CDCE_ADDR['reg12'];
            cdce_write_command(addr_p=addr,data_p=value);

        }


  function CDCE72010_get_reg_value(reg_name_p,level_p,mode_p,verbosity_p)
{
    // default function parameter values
    if (typeof(level_p)==='undefined') level_p = 0;
    if (typeof(mode_p)==='undefined') mode_p = 0;
    if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

    level0 = level_p;
    level1 = level_p + 1;


    // get the wireout values
    getLatestValue("FPA_WireOutValues");

    msg_field = '';
    error = 0;
    data = 0;
    dic = {};
    switch(reg_name_p) {
    case 'reg0':
        addr = CDCE_ADDR['reg0'];
        data = cdce_read_command(addr_p=addr);

        outbufsel0yx_p = ((data >> 26) & 0x3);
        cmosmode0nyx_p = ((data >> 24) & 0x3);
        cmosmode0pyx_p = ((data >> 22) & 0x3);
        pecl0hiswing_p = ((data >> 21) & 0x1);
        irefres_p = ((data >> 20) & 0x1);
        icp_p = ((data >> 14) & 0xF);
        cp_pre_p = ((data >> 13) & 0x1);
        cp_opa_p = ((data >> 12) & 0x1);
        cp_snk_p = ((data >> 11) & 0x1);
        cp_src_p = ((data >> 10) & 0x1);
        cp_dir_p = ((data >> 9) & 0x1);
        delay_pfd_p = ((data >> 6) & 0x3);
        refselcntrl_p = ((data >> 5) & 0x1);
        vcxosel_p = ((data >> 4) & 0x1);
        secsel_p = ((data >> 3) & 0x1);
        prisel_p = ((data >> 2) & 0x1);
        inbufselyx_p = ((data >> 0) & 0x3);
        
        msg_field = [
                'outbufsel0yx_p: 0x'+convert_int_to_str_hex(value_p=outbufsel0yx_p,width_p=2),
                'cmosmode0nyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode0nyx_p,width_p=2),
                'cmosmode0pyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode0pyx_p,width_p=2),
                'pecl0hiswing_p: 0x'+convert_int_to_str_hex(value_p=pecl0hiswing_p,width_p=1),
                'irefres_p: 0x'+convert_int_to_str_hex(value_p=irefres_p,width_p=1),
                'icp_p: 0x'+convert_int_to_str_hex(value_p=icp_p,width_p=4),
                'cp_pre_p: 0x'+convert_int_to_str_hex(value_p=cp_pre_p,width_p=1),
                'cp_opa_p: 0x'+convert_int_to_str_hex(value_p=cp_opa_p,width_p=1),
                'cp_snk_p: 0x'+convert_int_to_str_hex(value_p=cp_snk_p,width_p=1),
                'cp_src_p: 0x'+convert_int_to_str_hex(value_p=cp_src_p,width_p=1),
                'cp_dir_p: 0x'+convert_int_to_str_hex(value_p=cp_dir_p,width_p=1),
                'delay_pfd_p: 0x'+convert_int_to_str_hex(value_p=delay_pfd_p,width_p=2),
                'refselcntrl_p: 0x'+convert_int_to_str_hex(value_p=refselcntrl_p,width_p=1),
                'vcxosel_p: 0x'+convert_int_to_str_hex(value_p=vcxosel_p,width_p=1),
                'secsel_p: 0x'+convert_int_to_str_hex(value_p=secsel_p,width_p=1),
                'prisel_p: 0x'+convert_int_to_str_hex(value_p=prisel_p,width_p=1),
                'inbufselyx_p: 0x'+convert_int_to_str_hex(value_p=inbufselyx_p,width_p=2)

                ];
        break;
    case 'reg1':
        addr = CDCE_ADDR['reg1'];
        data = cdce_read_command(addr_p=addr);

        outbufsel1yx_p = ((data >> 26) & 0x3);
        cmosmode1nyx_p = ((data >> 24) & 0x3);
        cmosmode1pyx_p = ((data >> 22) & 0x3);
        pecl1hiswing_p = ((data >> 21) & 0x1);
        en01div_p = ((data >> 20) & 0x1);
        out1divrsel_p = ((data >> 13) & 0x7F);
        ph1adjc_p = ((data >> 6) & 0x7F);
        failsafe_p = ((data >> 5) & 0x1);
        secinvbb_p = ((data >> 4) & 0x1);
        priinvbb_p = ((data >> 3) & 0x1);
        termsel_p = ((data >> 2) & 0x1);
        hysten_p = ((data >> 1) & 0x1);
        acdcsel_p = ((data >> 0) & 0x1);

        
        msg_field = [
                'outbufsel1yx_p: 0x'+convert_int_to_str_hex(value_p=outbufsel1yx_p,width_p=2),
                'cmosmode1nyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode1nyx_p,width_p=2),
                'cmosmode1pyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode1pyx_p,width_p=2),
                'pecl1hiswing_p: 0x'+convert_int_to_str_hex(value_p=pecl1hiswing_p,width_p=1),
                'en01div_p: 0x'+convert_int_to_str_hex(value_p=en01div_p,width_p=1),
                'out1divrsel_p: 0x'+convert_int_to_str_hex(value_p=out1divrsel_p,width_p=7),
                'ph1adjc_p: 0x'+convert_int_to_str_hex(value_p=ph1adjc_p,width_p=7),
                'failsafe_p: 0x'+convert_int_to_str_hex(value_p=failsafe_p,width_p=1),
                'secinvbb_p: 0x'+convert_int_to_str_hex(value_p=secinvbb_p,width_p=1),
                'priinvbb_p: 0x'+convert_int_to_str_hex(value_p=priinvbb_p,width_p=1),
                'termsel_p: 0x'+convert_int_to_str_hex(value_p=termsel_p,width_p=1),
                'hysten_p: 0x'+convert_int_to_str_hex(value_p=hysten_p,width_p=1),
                'acdcsel_p: 0x'+convert_int_to_str_hex(value_p=acdcsel_p,width_p=1)

                ];
        break;
    case 'reg2':
        addr = CDCE_ADDR['reg2'];
        data = cdce_read_command(addr_p=addr);

        outbufsel2yx_p = ((data >> 26) & 0x3);
        cmosmode2nyx_p = ((data >> 24) & 0x3);
        cmosmode2pyx_p = ((data >> 22) & 0x3);
        pecl2hiswing_p = ((data >> 21) & 0x1);
        en2div_p = ((data >> 20) & 0x1);
        out2divrsel_p = ((data >> 13) & 0x7F);
        ph2adjc_p = ((data >> 6) & 0x7F);
        dlyn_p = ((data >> 3) & 0x7);
        dlym_p = ((data >> 0) & 0x7);

        msg_field = [
                'outbufsel2yx_p: 0x'+convert_int_to_str_hex(value_p=outbufsel2yx_p,width_p=2),
                'cmosmode2nyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode2nyx_p,width_p=2),
                'cmosmode2pyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode2pyx_p,width_p=2),
                'pecl2hiswing_p: 0x'+convert_int_to_str_hex(value_p=pecl2hiswing_p,width_p=1),
                'en2div_p: 0x'+convert_int_to_str_hex(value_p=en2div_p,width_p=1),
                'out2divrsel_p: 0x'+convert_int_to_str_hex(value_p=out2divrsel_p,width_p=7),
                'ph2adjc_p: 0x'+convert_int_to_str_hex(value_p=ph2adjc_p,width_p=7),
                'dlyn_p: 0x'+convert_int_to_str_hex(value_p=dlyn_p,width_p=3),
                'dlym_p: 0x'+convert_int_to_str_hex(value_p=dlym_p,width_p=3)

                ];
        break;
    case 'reg3':
        addr = CDCE_ADDR['reg3'];
        data = cdce_read_command(addr_p=addr);

        outbufsel3yx_p = ((data >> 26) & 0x3);
        cmosmode3nyx_p = ((data >> 24) & 0x3);
        cmosmode3pyx_p = ((data >> 22) & 0x3);
        pecl3hiswing_p = ((data >> 21) & 0x1);
        en3div_p = ((data >> 20) & 0x1);
        out3divrsel_p = ((data >> 13) & 0x7F);
        ph3adjc_p = ((data >> 6) & 0x7F);
        bias_div23_p = ((data >> 4) & 0x3);
        bias_div01_p = ((data >> 2) & 0x3);
        dis_fdet_fb_p = ((data >> 1) & 0x1);
        dis_fdet_ref_p = ((data >> 0) & 0x1);

        msg_field = [
                'outbufsel3yx_p: 0x'+convert_int_to_str_hex(value_p=outbufsel3yx_p,width_p=2),
                'cmosmode3nyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode3nyx_p,width_p=2),
                'cmosmode3pyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode3pyx_p,width_p=2),
                'pecl3hiswing_p: 0x'+convert_int_to_str_hex(value_p=pecl3hiswing_p,width_p=1),
                'en3div_p: 0x'+convert_int_to_str_hex(value_p=en3div_p,width_p=1),
                'out3divrsel_p: 0x'+convert_int_to_str_hex(value_p=out3divrsel_p,width_p=7),
                'ph3adjc_p: 0x'+convert_int_to_str_hex(value_p=ph3adjc_p,width_p=7),
                'bias_div23_p: 0x'+convert_int_to_str_hex(value_p=bias_div23_p,width_p=2),
                'bias_div01_p: 0x'+convert_int_to_str_hex(value_p=bias_div01_p,width_p=2),
                'dis_fdet_fb_p: 0x'+convert_int_to_str_hex(value_p=dis_fdet_fb_p,width_p=1),
                'dis_fdet_ref_p: 0x'+convert_int_to_str_hex(value_p=dis_fdet_ref_p,width_p=1)

                ];
        break;
    case 'reg4':
        addr = CDCE_ADDR['reg4'];
        data = cdce_read_command(addr_p=addr);

        outbufsel4yx_p = ((data >> 26) & 0x3);
        cmosmode4nyx_p = ((data >> 24) & 0x3);
        cmosmode4pyx_p = ((data >> 22) & 0x3);
        pecl4hiswing_p = ((data >> 21) & 0x1);
        en4div_p = ((data >> 20) & 0x1);
        out4divrsel_p = ((data >> 13) & 0x7F);
        ph4adjc_p = ((data >> 6) & 0x7F);
        holdonlor_p = ((data >> 4) & 0x1);


        msg_field = [
                'outbufsel4yx_p: 0x'+convert_int_to_str_hex(value_p=outbufsel4yx_p,width_p=2),
                'cmosmode4nyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode4nyx_p,width_p=2),
                'cmosmode4pyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode4pyx_p,width_p=2),
                'pecl4hiswing_p: 0x'+convert_int_to_str_hex(value_p=pecl4hiswing_p,width_p=1),
                'en4div_p: 0x'+convert_int_to_str_hex(value_p=en4div_p,width_p=1),
                'out4divrsel_p: 0x'+convert_int_to_str_hex(value_p=out4divrsel_p,width_p=7),
                'ph4adjc_p: 0x'+convert_int_to_str_hex(value_p=ph4adjc_p,width_p=7),
                'holdonlor_p: 0x'+convert_int_to_str_hex(value_p=holdonlor_p,width_p=1)

                ];
        break;
    case 'reg5':
        addr = CDCE_ADDR['reg5'];
        data = cdce_read_command(addr_p=addr);

        outbufsel5yx_p = ((data >> 26) & 0x3);
        cmosmode5nyx_p = ((data >> 24) & 0x3);
        cmosmode5pyx_p = ((data >> 22) & 0x3);
        pecl5hiswing_p = ((data >> 21) & 0x1);
        en5div_p = ((data >> 20) & 0x1);
        out5divrsel_p = ((data >> 13) & 0x7F);
        ph5adjc_p = ((data >> 6) & 0x7F);
        bias_div67_p = ((data >> 2) & 0x3);
        bias_div45_p = ((data >> 0) & 0x3);


        msg_field = [
                'outbufsel5yx_p: 0x'+convert_int_to_str_hex(value_p=outbufsel5yx_p,width_p=2),
                'cmosmode5nyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode5nyx_p,width_p=2),
                'cmosmode5pyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode5pyx_p,width_p=2),
                'pecl5hiswing_p: 0x'+convert_int_to_str_hex(value_p=pecl5hiswing_p,width_p=1),
                'en5div_p: 0x'+convert_int_to_str_hex(value_p=en5div_p,width_p=1),
                'out5divrsel_p: 0x'+convert_int_to_str_hex(value_p=out5divrsel_p,width_p=7),
                'ph5adjc_p: 0x'+convert_int_to_str_hex(value_p=ph5adjc_p,width_p=7),

                'bias_div67_p: 0x'+convert_int_to_str_hex(value_p=bias_div67_p,width_p=2),
                'bias_div45_p: 0x'+convert_int_to_str_hex(value_p=bias_div45_p,width_p=2)

                ];
        break;
    case 'reg6':
        addr = CDCE_ADDR['reg6'];
        data = cdce_read_command(addr_p=addr);

        outbufsel6yx_p = ((data >> 26) & 0x3);
        cmosmode6nyx_p = ((data >> 24) & 0x3);
        cmosmode6pyx_p = ((data >> 22) & 0x3);
        pecl6hiswing_p = ((data >> 21) & 0x1);
        en6div_p = ((data >> 20) & 0x1);
        out6divrsel_p = ((data >> 13) & 0x7F);
        ph6adjc_p = ((data >> 6) & 0x7F);
        det_start_bypass = ((data >> 5) & 0x1);
        fb_start_bypass_p = ((data >> 4) & 0x1);
        fbdeterm_div2_dis_p = ((data >> 3) & 0x1);
        fbdeterm_div_sel_p = ((data >> 2) & 0x1);
        fb_fd_desel_p = ((data >> 0) & 0x1);


        msg_field = [
                'outbufsel6yx_p: 0x'+convert_int_to_str_hex(value_p=outbufsel6yx_p,width_p=2),
                'cmosmode6nyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode6nyx_p,width_p=2),
                'cmosmode6pyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode6pyx_p,width_p=2),
                'pecl6hiswing_p: 0x'+convert_int_to_str_hex(value_p=pecl6hiswing_p,width_p=1),
                'en6div_p: 0x'+convert_int_to_str_hex(value_p=en6div_p,width_p=1),
                'out6divrsel_p: 0x'+convert_int_to_str_hex(value_p=out6divrsel_p,width_p=7),
                'ph6adjc_p: 0x'+convert_int_to_str_hex(value_p=ph6adjc_p,width_p=7),

                'det_start_bypass: 0x'+convert_int_to_str_hex(value_p=det_start_bypass,width_p=1),
                'fb_start_bypass_p: 0x'+convert_int_to_str_hex(value_p=fb_start_bypass_p,width_p=1),
                'fbdeterm_div2_dis_p: 0x'+convert_int_to_str_hex(value_p=fbdeterm_div2_dis_p,width_p=1),
                'fbdeterm_div_sel_p: 0x'+convert_int_to_str_hex(value_p=fbdeterm_div_sel_p,width_p=1),
                'fb_fd_desel_p: 0x'+convert_int_to_str_hex(value_p=fb_fd_desel_p,width_p=1)

                ];

        break;
    case 'reg7':

        addr = CDCE_ADDR['reg7'];
        data = cdce_read_command(addr_p=addr);

        outbufsel7yx_p = ((data >> 26) & 0x3);
        cmosmode7nyx_p = ((data >> 24) & 0x3);
        cmosmode7pyx_p = ((data >> 22) & 0x3);
        pecl7hiswing_p = ((data >> 21) & 0x1);
        en7div_p = ((data >> 20) & 0x1);
        out7divrsel_p = ((data >> 13) & 0x7F);
        ph7adjc_p = ((data >> 6) & 0x7F);

        adlock_p = ((data >> 5) & 0x1);
        lockc_p = ((data >> 3) & 0x3);
        lockw_p = ((data >> 0) & 0x3);



        msg_field = [
                'outbufsel7yx_p: 0x'+convert_int_to_str_hex(value_p=outbufsel7yx_p,width_p=2),
                'cmosmode7nyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode7nyx_p,width_p=2),
                'cmosmode7pyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode7pyx_p,width_p=2),
                'pecl7hiswing_p: 0x'+convert_int_to_str_hex(value_p=pecl7hiswing_p,width_p=1),
                'en7div_p: 0x'+convert_int_to_str_hex(value_p=en7div_p,width_p=1),
                'out7divrsel_p: 0x'+convert_int_to_str_hex(value_p=out7divrsel_p,width_p=7),
                'ph7adjc_p: 0x'+convert_int_to_str_hex(value_p=ph7adjc_p,width_p=7),

                'adlock_p: 0x'+convert_int_to_str_hex(value_p=adlock_p,width_p=1),
                'lockc_p: 0x'+convert_int_to_str_hex(value_p=lockc_p,width_p=2),
                'lockw_p: 0x'+convert_int_to_str_hex(value_p=lockw_p,width_p=2)

                ];
        break;
    case 'reg8':
        addr = CDCE_ADDR['reg8'];
        data = cdce_read_command(addr_p=addr);

        outbufsel8yx_p = ((data >> 26) & 0x3);
        cmosmode8nyx_p = ((data >> 24) & 0x3);
        cmosmode8pyx_p = ((data >> 22) & 0x3);
        pecl8hiswing_p = ((data >> 21) & 0x1);
        en8div_p = ((data >> 20) & 0x1);
        out8divrsel_p = ((data >> 13) & 0x7F);
        ph8adjc_p = ((data >> 6) & 0x7F);

        vcxoinvbb_p = ((data >> 5) & 0x1);
        vcxotermsel_p = ((data >> 4) & 0x1);
        vcxohysten_p = ((data >> 3) & 0x1);
        vcxoacdcsel_p = ((data >> 2) & 0x1);
        vcxobufselyx_p = ((data >> 0) & 0x3);



        msg_field = [
                'outbufsel8yx_p: 0x'+convert_int_to_str_hex(value_p=outbufsel8yx_p,width_p=2),
                'cmosmode8nyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode8nyx_p,width_p=2),
                'cmosmode8pyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode8pyx_p,width_p=2),
                'pecl8hiswing_p: 0x'+convert_int_to_str_hex(value_p=pecl8hiswing_p,width_p=1),
                'en8div_p: 0x'+convert_int_to_str_hex(value_p=en8div_p,width_p=1),
                'out8divrsel_p: 0x'+convert_int_to_str_hex(value_p=out8divrsel_p,width_p=7),
                'ph8adjc_p: 0x'+convert_int_to_str_hex(value_p=ph8adjc_p,width_p=7),

                'vcxoinvbb_p: 0x'+convert_int_to_str_hex(value_p=vcxoinvbb_p,width_p=1),
                'vcxotermsel_p: 0x'+convert_int_to_str_hex(value_p=vcxotermsel_p,width_p=1),
                'vcxohysten_p: 0x'+convert_int_to_str_hex(value_p=vcxohysten_p,width_p=1),
                'vcxoacdcsel_p: 0x'+convert_int_to_str_hex(value_p=vcxoacdcsel_p,width_p=1),
                'vcxobufselyx_p: 0x'+convert_int_to_str_hex(value_p=vcxobufselyx_p,width_p=2)

                ];
        break;
    case 'reg9':
        addr = CDCE_ADDR['reg9'];
        data = cdce_read_command(addr_p=addr);

        outbufsel9yx_p = ((data >> 26) & 0x3);
        cmosmode9nyx_p = ((data >> 24) & 0x3);
        cmosmode9pyx_p = ((data >> 22) & 0x3);
        pecl9hiswing_p = ((data >> 21) & 0x1);

        dis_aux_y9_p = ((data >> 20) & 0x1);
        auxinvbb_p = ((data >> 19) & 0x1);
        bias_div89_p = ((data >> 17) & 0x3);
        bias_div_fb_p = ((data >> 15) & 0x3);

        npreset_mdiv_p = ((data >> 14) & 0x1);
        low_fd_fb_en_p = ((data >> 13) & 0x1);
        pll_lock_bp_p = ((data >> 12) & 0x1);
        indet_bp_p = ((data >> 11) & 0x1);
        start_bypass_p = ((data >> 10) & 0x1);
        divsync_dis_p = ((data >> 9) & 0x1);
        noinv_reshol_int_p = ((data >> 8) & 0x1);
        lockw32_p = ((data >> 6) & 0x3);
        hold_cnt_p = ((data >> 4) & 0x3);
        holdtr_p = ((data >> 3) & 0x1);
        hold_n_p = ((data >> 2) & 0x1);
        holdf_p = ((data >> 0) & 0x1);



        msg_field = [
                'outbufsel9yx_p: 0x'+convert_int_to_str_hex(value_p=outbufsel9yx_p,width_p=2),
                'cmosmode9nyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode9nyx_p,width_p=2),
                'cmosmode9pyx_p: 0x'+convert_int_to_str_hex(value_p=cmosmode9pyx_p,width_p=2),
                'pecl9hiswing_p: 0x'+convert_int_to_str_hex(value_p=pecl9hiswing_p,width_p=1),


                'dis_aux_y9_p: 0x'+convert_int_to_str_hex(value_p=dis_aux_y9_p,width_p=1),
                'auxinvbb_p: 0x'+convert_int_to_str_hex(value_p=auxinvbb_p,width_p=1),

                'bias_div89_p: 0x'+convert_int_to_str_hex(value_p=bias_div89_p,width_p=2),
                'bias_div_fb_p: 0x'+convert_int_to_str_hex(value_p=bias_div_fb_p,width_p=2),

                'npreset_mdiv_p: 0x'+convert_int_to_str_hex(value_p=npreset_mdiv_p,width_p=1),
                'low_fd_fb_en_p: 0x'+convert_int_to_str_hex(value_p=low_fd_fb_en_p,width_p=1),
                'pll_lock_bp_p: 0x'+convert_int_to_str_hex(value_p=pll_lock_bp_p,width_p=1),
                'indet_bp_p: 0x'+convert_int_to_str_hex(value_p=indet_bp_p,width_p=1),
                'start_bypass_p: 0x'+convert_int_to_str_hex(value_p=start_bypass_p,width_p=1),
                'divsync_dis_p: 0x'+convert_int_to_str_hex(value_p=divsync_dis_p,width_p=1),
                'noinv_reshol_int_p: 0x'+convert_int_to_str_hex(value_p=noinv_reshol_int_p,width_p=1),
                'lockw32_p: 0x'+convert_int_to_str_hex(value_p=lockw32_p,width_p=2),
                'hold_cnt_p: 0x'+convert_int_to_str_hex(value_p=hold_cnt_p,width_p=2),
                'holdtr_p: 0x'+convert_int_to_str_hex(value_p=holdtr_p,width_p=1),
                'hold_n_p: 0x'+convert_int_to_str_hex(value_p=hold_n_p,width_p=1),
                'holdf_p: 0x'+convert_int_to_str_hex(value_p=holdf_p,width_p=1)

                ];
        break;
    case 'reg10':
        addr = CDCE_ADDR['reg10'];
        data = cdce_read_command(addr_p=addr);

        div_n_p = ((data >> 14) & 0x3FFF);
        div_m_p = ((data >> 0) & 0x3FFF);

        msg_field = [
                'div_n_p: 0x'+convert_int_to_str_hex(value_p=div_n_p,width_p=14),
                'div_m_p: 0x'+convert_int_to_str_hex(value_p=div_m_p,width_p=14)

                ];

        
        break;

    case 'reg11':
        addr = CDCE_ADDR['reg11'];
        data = cdce_read_command(addr_p=addr);

        eplock_p = ((data >> 26) & 0x1);
        reset_hold_mode_p = ((data >> 25) & 0x1);
        sel_del1_p = ((data >> 24) & 0x1);
        nreshape1_p = ((data >> 23) & 0x1);
        fb_sel_p = ((data >> 22) & 0x1);
        out_mux_sel_p = ((data >> 21) & 0x1);
        fb_mux_sel_p = ((data >> 20) & 0x1);
        pd_pll_p = ((data >> 19) & 0x1);
        fb_phase_p = ((data >> 13) & 0x7F);
        fb_count32_p = ((data >> 5) & 0x7F);
        fb_inclk_inv_p = ((data >> 4) & 0x1);
        fb_cml_sel_p = ((data >> 3) & 0x1);
        fb_dis_p = ((data >> 2) & 0x1);
        sec_div2_p = ((data >> 1) & 0x1);
        pri_div2_p = ((data >> 0) & 0x1);

        msg_field = [
                'eplock_p: 0x'+convert_int_to_str_hex(value_p=eplock_p,width_p=1),
                'reset_hold_mode_p: 0x'+convert_int_to_str_hex(value_p=reset_hold_mode_p,width_p=1),
                'sel_del1_p: 0x'+convert_int_to_str_hex(value_p=sel_del1_p,width_p=1),
                'nreshape1_p: 0x'+convert_int_to_str_hex(value_p=nreshape1_p,width_p=1),
                'fb_sel_p: 0x'+convert_int_to_str_hex(value_p=fb_sel_p,width_p=1),
                'out_mux_sel_p: 0x'+convert_int_to_str_hex(value_p=out_mux_sel_p,width_p=1),
                'fb_mux_sel_p: 0x'+convert_int_to_str_hex(value_p=fb_mux_sel_p,width_p=1),
                'pd_pll_p: 0x'+convert_int_to_str_hex(value_p=pd_pll_p,width_p=1),
                'fb_phase_p: 0x'+convert_int_to_str_hex(value_p=fb_phase_p,width_p=7),
                'fb_count32_p: 0x'+convert_int_to_str_hex(value_p=fb_count32_p,width_p=7),
                'fb_inclk_inv_p: 0x'+convert_int_to_str_hex(value_p=fb_inclk_inv_p,width_p=1),
                'fb_cml_sel_p: 0x'+convert_int_to_str_hex(value_p=fb_cml_sel_p,width_p=1),
                'fb_dis_p: 0x'+convert_int_to_str_hex(value_p=fb_dis_p,width_p=1),
                'sec_div2_p: 0x'+convert_int_to_str_hex(value_p=sec_div2_p,width_p=1),
                'pri_div2_p: 0x'+convert_int_to_str_hex(value_p=pri_div2_p,width_p=1)

                ];

        
        break;
    case 'reg12':
        addr = CDCE_ADDR['reg12'];
        data = cdce_read_command(addr_p=addr);

        secactivity_p = ((data >> 26) & 0x1);
        priactivity_p = ((data >> 25) & 0x1);
        titstcfg_p = ((data >> 21) & 0xF);
        status_p = ((data >> 17) & 0xF);
        shold_p = ((data >> 15) & 0x1);
        sxoiref_p = ((data >> 14) & 0x1);
        pd_io_p = ((data >> 13) & 0x1);
        revision_p = ((data >> 10) & 0x7);
        gtme_p = ((data >> 9) & 0x1);
        reset_hold_n_p = ((data >> 8) & 0x1);
        sleep_n_p = ((data >> 7) & 0x1);
        pll_lock_p = ((data >> 6) & 0x1);
        indet_vcxo_p = ((data >> 5) & 0x1);
        indet_aux_p = ((data >> 4) & 0x1);

        msg_field = [
                'secactivity_p: 0x'+convert_int_to_str_hex(value_p=secactivity_p,width_p=1),
                'priactivity_p: 0x'+convert_int_to_str_hex(value_p=priactivity_p,width_p=1),
                'titstcfg_p: 0x'+convert_int_to_str_hex(value_p=titstcfg_p,width_p=4),
                'status_p: 0x'+convert_int_to_str_hex(value_p=status_p,width_p=4),

                'shold_p: 0x'+convert_int_to_str_hex(value_p=shold_p,width_p=1),
                'sxoiref_p: 0x'+convert_int_to_str_hex(value_p=sxoiref_p,width_p=1),
                'pd_io_p: 0x'+convert_int_to_str_hex(value_p=pd_io_p,width_p=1),
                'revision_p: 0x'+convert_int_to_str_hex(value_p=revision_p,width_p=3),
                'gtme_p: 0x'+convert_int_to_str_hex(value_p=gtme_p,width_p=1),
                'reset_hold_n_p: 0x'+convert_int_to_str_hex(value_p=reset_hold_n_p,width_p=1),
                'sleep_n_p: 0x'+convert_int_to_str_hex(value_p=sleep_n_p,width_p=1),
                'pll_lock_p: 0x'+convert_int_to_str_hex(value_p=pll_lock_p,width_p=1),
                'indet_vcxo_p: 0x'+convert_int_to_str_hex(value_p=indet_vcxo_p,width_p=1),
                'indet_aux_p: 0x'+convert_int_to_str_hex(value_p=indet_aux_p,width_p=1)

                ];
        break;
    
    default:
        msg = "[CDCE72010_get_reg_value]: Error" + reg_name_p + " doesn't exist."
        display_error(msg_p=msg, level_p=level0, mode_p=mode_p);
        error = 1;
        break;
    }


    dic['data'] = data;
    dic['error'] = error;

    /*
        print field values
    */
    if (verbosity_p > 0)
    {
		msg = "DATA : " + data.toString(16);
		display(msg_p=msg, level_p=level0, mode_p=mode_p);
        display(msg_p=msg_field, level_p=level0, mode_p=mode_p);
    }

    return dic;


}


//###############################################################
// Configure the CDCE72010 Device
//###############################################################
function CDCE72010_configure(verbosity_p)
    {

	if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

    cdce_init_device();

    //###############################################################
    // config0
    //###############################################################
    // [27:26]: R/W: outbufsel0yx[1:0]
    // [25:24]: R/W: cmosmode0nyx[1:0]
    // [23:22]: R/W: cmosmode0pyx[1:0]
    // [21]: R/W: pecl0hiswing[0]
    // [20]: R/W: irefres[0]
    // [17:14]: R/W: icp[3:0]
    // [13]: R/W: cp_pre[0]
    // [12]: R/W: cp_opa[0]
    // [11]: R/W: cp_snk[0]
    // [10]: R/W: cp_src[0]
    // [9]: R/W: cp_dir[0]
    // [7:6]: R/W: delay_pfd[1:0]
    // [5]: R/W: refselcntrl[0]
    // [4]: R/W: vcxosel[0]
    // [3]: R/W: secsel[0]
    // [2]: R/W: prisel[0]
    // [1:0]: R/W: inbufselyx[1:0]

    outbufsel0yx = parseInt('01',2); // disable output0
    cmosmode0nyx = parseInt('10',2); // disable output0
    cmosmode0pyx = parseInt('10',2); // disable output0
    pecl0hiswing = 0; //0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    irefres = 0;
    icp = parseInt('1111',2);
    cp_pre = 0; // Preset charge pump output voltage to VCC_CP/2, on [1], off [0] 
    cp_opa = 0;
    cp_snk = 0;
    cp_src = 0;
    cp_dir = 0;
    delay_pfd = parseInt('00',2); // delay on the reset path: 1.5 ns (default)
    refselcntrl = 1;// 1: use register0 to select ref_clk
    vcxosel = 1; // 0; use register0 to select ref_clk, 1: use VCXO/AUX-clock
    secsel = 0; // use prim_ref
    prisel = 1;
    inbufselyx = parseInt('11',2);//LVDS PRI_Ref/SEC_Ref

    cdce_set_config0(
                    outbufsel0yx_p=outbufsel0yx,cmosmode0nyx_p = cmosmode0nyx,
                    cmosmode0pyx_p = cmosmode0pyx,pecl0hiswing_p = pecl0hiswing,irefres_p=irefres,
                    icp_p=icp,cp_pre_p=cp_pre, cp_opa_p=cp_opa,
                    cp_snk_p=cp_snk,cp_src_p=cp_src,cp_dir_p=cp_dir,
                    delay_pfd_p=delay_pfd,refselcntrl_p=refselcntrl,vcxosel_p=vcxosel,
                    secsel_p=secsel,prisel_p=prisel,inbufselyx_p=inbufselyx
              );

    //###############################################################
    // config1
    //###############################################################
    // [27:26]: R/W: outbufsel1yx[1:0]
    // [25:24]: R/W: cmosmode1nyx[1:0]
    // [23:22]: R/W: cmosmode1pyx[1:0]
    // [21]: R/W: pecl1hiswing[0]
    // [20]: R/W: en01div[0]
    // [19:13]: R/W: out1divrsel[6:0]
    // [12:6]: R/W: ph1adjc[6:0]
    // [5]: R/W: failsafe[0]
    // [4]: R/W: secinvbb[0]
    // [3]: R/W: priinvbb[0]
    // [2]: R/W: termsel[0]
    // [1]: R/W: hysten[0]
    // [0]: R/W: acdcsel[0]

    outbufsel1yx = parseInt('01',2); // disable output1
    cmosmode1nyx = parseInt('10',2); // disable output1
    cmosmode1pyx = parseInt('10',2); // disable output1
    pecl1hiswing = 0; //0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en01div = 0; //0: divider is disabled on output0/output1
    out1divrsel = parseInt('000_0000',2);
    ph1adjc = parseInt('000_0000',2);
    failsafe = 0;
    secinvbb = 0;
    priinvbb = 0;
    termsel = 0; 
    hysten = 1;
    acdcsel = 0;

    cdce_set_config1(
                    outbufsel1yx_p=outbufsel1yx,cmosmode1nyx_p=cmosmode1nyx,
                    cmosmode1pyx_p=cmosmode1pyx,pecl1hiswing_p=pecl1hiswing,en01div_p=en01div, 
                    out1divrsel_p=out1divrsel, ph1adjc_p=ph1adjc,
                    failsafe_p=failsafe,secinvbb_p=secinvbb,
                    priinvbb_p=priinvbb,termsel_p=termsel,hysten_p=hysten,acdcsel_p=acdcsel
                    );

    //###############################################################
    // config2
    //###############################################################
    // [27:26]: R/W: outbufsel2yx[1:0]
    // [25:24]: R/W: cmosmode2nyx[1:0]
    // [23:22]: R/W: cmosmode2pyx[1:0]
    // [21]: R/W: pecl2hiswing[0]
    // [20]: R/W: en2div[0]
    // [19:13]: R/W: out2divrsel[6:0]
    // [12:6]: R/W: ph2adjc[6:0]
    // [5:3]: R/W: dlyn[2:0]
    // [2:0]: R/W: dlym[2:0]
    outbufsel2yx = parseInt('10',2); // LVPECL output2
    cmosmode2nyx = parseInt('00',2); // LVPECL output2
    cmosmode2pyx = parseInt('00',2); // LVPECL output2
    pecl2hiswing = 1; //0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en2div = 1; //0: divider is disabled on output2, 1: otherwise
    out2divrsel = parseInt('1000000',2); // Output Divider 2 ratio select: divided by 2
    ph2adjc = parseInt('0000000',2);
    dlyn = parseInt('00',2); // Feedback phase delay. (default:'00' <=> 0ps (page 55)).If Progr Delay N is set, all Yx outputs are leading to the Reference Clock according to the value set
    dlym = parseInt('00',2);// Reference phase delay. (default:'00' <=> 0ps (page 55)). If Progr Delay M is set, all Yx outputs are lagging to the Reference Clock according to the value set

    cdce_set_config2(
                    outbufsel2yx_p=outbufsel2yx,cmosmode2nyx_p=cmosmode2nyx,
                    cmosmode2pyx_p=cmosmode2pyx,pecl2hiswing_p=pecl2hiswing,en2div_p=en2div, 
                    out2divrsel_p=out2divrsel, ph2adjc_p=ph2adjc,
                    dlyn_p=dlyn,dlym_p=dlym
                    );

    //###############################################################
    // config3
    //###############################################################
    // [27:26]: R/W: outbufsel3yx[1:0]
    // [25:24]: R/W: cmosmode3nyx[1:0]
    // [23:22]: R/W: cmosmode3pyx[1:0]
    // [21]: R/W: pecl3hiswing[0]
    // [20]: R/W: en3div[0]
    // [19:13]: R/W: out3divrsel[6:0]
    // [12:6]: R/W: ph3adjc[6:0]
    // [5:4]: R/W: bias_div23[1:0]
    // [3:2]: R/W: bias_div01[1:0]
    // [1]: R/W: dis_fdet_fb[0]
    // [0]: R/W: dis_fdet_ref[0]

    outbufsel3yx = parseInt('01',2);// disable output3
    cmosmode3nyx = parseInt('10',2);// disable output3
    cmosmode3pyx = parseInt('10',2);// disable output3
    pecl3hiswing = 0;//0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en3div = 0;//0: divider is disabled on output3, 1: otherwise
    out3divrsel = parseInt('0000000',2);
    ph3adjc = parseInt('0000000',2);
    bias_div23 = parseInt('00',2);
    bias_div01 = parseInt('00',2);
    dis_fdet_fb = 0;
    dis_fdet_ref = 0;// 0: ref clock frequency detector is ON, 1: otherwise

    cdce_set_config3(
                    outbufsel3yx_p=outbufsel3yx,cmosmode3nyx_p=cmosmode3nyx,
                    cmosmode3pyx_p=cmosmode3pyx,pecl3hiswing_p=pecl3hiswing,en3div_p=en3div, 
                    out3divrsel_p=out3divrsel, ph3adjc_p=ph3adjc,
                    bias_div23_p=bias_div23,
                    bias_div01_p=bias_div01, dis_fdet_fb_p=dis_fdet_fb,dis_fdet_ref_p=dis_fdet_ref
                    );

    //###############################################################
    // config4
    //###############################################################
    // [27:26]: R/W: outbufsel4yx[1:0]
    // [25:24]: R/W: cmosmode4nyx[1:0]
    // [23:22]: R/W: cmosmode4pyx[1:0]
    // [21]: R/W: pecl4hiswing[0]
    // [20]: R/W: en4div[0]
    // [19:13]: R/W: out4divrsel[6:0]
    // [12:6]: R/W: ph4adjc[6:0]
    // [4]: R/W: holdonlor[0]

    outbufsel4yx = parseInt('11',2); // LVDS output4
    cmosmode4nyx = parseInt('10',2); // LVDS output4
    cmosmode4pyx = parseInt('10',2); // LVDS output4
    pecl4hiswing = 0;//0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en4div = 1;//0: divider is disabled on output4, 1: otherwise
    out4divrsel = parseInt('1000000',2); // Output Divider 4 ratio select: divided by 2
    ph4adjc = parseInt('000_0000',2);
    holdonlor = 0;//If set to 0, CP remains active and will discharge loop filter if input reference clock is lost

    cdce_set_config4(
                    outbufsel4yx_p=outbufsel4yx,cmosmode4nyx_p=cmosmode4nyx,
                    cmosmode4pyx_p=cmosmode4pyx,pecl4hiswing_p=pecl4hiswing,en4div_p=en4div, 
                    out4divrsel_p=out4divrsel, ph4adjc_p=ph4adjc,
                    holdonlor_p=holdonlor
                    );

    //###############################################################
    // config5
    //###############################################################
    // [27:26]: R/W: outbufsel5yx[1:0]
    // [25:24]: R/W: cmosmode5nyx[1:0]
    // [23:22]: R/W: cmosmode5pyx[1:0]
    // [21]: R/W: pecl5hiswing[0]
    // [20]: R/W: en5div[0]
    // [19:13]: R/W: out5divrsel[6:0]
    // [12:6]: R/W: ph5adjc[6:0]
    // [3:2]: R/W: bias_div67[1:0]
    // [1:0]: R/W: bias_div45[1:0]
    outbufsel5yx = parseInt('01',2); // disable output5
    cmosmode5nyx = parseInt('10',2); // disable output5
    cmosmode5pyx = parseInt('10',2); // disable output5
    pecl5hiswing = 0; //0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en5div = 0; //0: divider is disabled on output5, 1: otherwise
    out5divrsel = parseInt('0000000',2);
    ph5adjc = parseInt('0000000',2);
    bias_div67 = parseInt('00',2);//00, No current reduction for all output-divider
    bias_div45 = parseInt('00',2);//00, No current reduction for all output-divider


    cdce_set_config5(
                    outbufsel5yx_p=outbufsel5yx,cmosmode5nyx_p=cmosmode5nyx,
                    cmosmode5pyx_p=cmosmode5pyx,pecl5hiswing_p=pecl5hiswing,en5div_p=en5div, 
                    out5divrsel_p=out5divrsel, ph5adjc_p=ph5adjc,
                    bias_div67_p=bias_div67,bias_div45_p=bias_div45
                    );

    //###############################################################
    // config6
    //###############################################################
    // [27:26]: R/W: outbufsel6yx[1:0]
    // [25:24]: R/W: cmosmode6nyx[1:0]
    // [23:22]: R/W: cmosmode6pyx[1:0]
    // [21]: R/W: pecl6hiswing[0]
    // [20]: R/W: en6div[0]
    // [19:13]: R/W: out6divrsel[6:0]
    // [12:6]: R/W: ph6adjc[6:0]
    // [5]: R/W: det_start_bypass[0]
    // [4]: R/W: fb_start_bypass[0]
    // [3]: R/W: fbdeterm_div2_dis[0]
    // [2]: R/W: fbdeterm_div_sel[0]
    // [0]: R/W: fb_fd_desel[0]
    outbufsel6yx = parseInt('01',2);// disable output6
    cmosmode6nyx = parseInt('10',2);// disable output6
    cmosmode6pyx = parseInt('10',2);// disable output6
    pecl6hiswing = 0;//0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en6div = 0;//0: divider is disabled on output6, 1: otherwise
    out6divrsel = parseInt('0000000',2);
    ph6adjc = parseInt('0000000',2);
    det_start_bypass = 0; // 0: Output-Dividers started with delay block (RC), normal operation, 1:Output-Dividers can be started with external NRESET-signal (pin)
    fb_start_bypass = 0;
    fbdeterm_div2_dis = 0;
    fbdeterm_div_sel = 0;
    fb_fd_desel = 0;

    cdce_set_config6(
                    outbufsel6yx_p=outbufsel6yx,cmosmode6nyx_p=cmosmode6nyx,
                    cmosmode6pyx_p=cmosmode6pyx,pecl6hiswing_p=pecl6hiswing,en6div_p=en6div, 
                    out6divrsel_p=out6divrsel, ph6adjc_p=ph6adjc,
                    det_start_bypass_p=det_start_bypass,fb_start_bypass_p=fb_start_bypass,
                    fbdeterm_div2_dis_p=fbdeterm_div2_dis,fbdeterm_div_sel_p=fbdeterm_div_sel,fb_fd_desel_p=fb_fd_desel
                    );

    //###############################################################
    // config7
    //###############################################################
    // [27:26]: R/W: outbufsel7yx[1:0]
    // [25:24]: R/W: cmosmode7nyx[1:0]
    // [23:22]: R/W: cmosmode7pyx[1:0]
    // [21]: R/W: pecl7hiswing[0]
    // [20]: R/W: en7div[0]
    // [19:13]: R/W: out7divrsel[6:0]
    // [12:6]: R/W: ph7adjc[6:0]
    // [5]: R/W: adlock[0]
    // [4:3]: R/W: lockc[1:0]
    // [1:0]: R/W: lockw[1:0]
    outbufsel7yx = parseInt('10',2);// LVPECL output7
    cmosmode7nyx = parseInt('00',2);// LVPECL output7
    cmosmode7pyx = parseInt('00',2);// LVPECL output7
    pecl7hiswing = 1;//0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en7div = 1;//0: divider is disabled on output7, 1: otherwise
    out7divrsel = parseInt('1000000',2); // Output Divider 7 ratio select: divided by 2
    ph7adjc = parseInt('0000000',2);
    adlock = 0;
    lockc = parseInt('00',2); // Number of coherent lock events (page 59) ("00": default : 1 successive lock event)
    lockw = parseInt('01',2); // Lock-detect window (default : 01)

    cdce_set_config7(
                    outbufsel7yx_p=outbufsel7yx,cmosmode7nyx_p=cmosmode7nyx,
                    cmosmode7pyx_p=cmosmode7pyx,pecl7hiswing_p=pecl7hiswing,en7div_p=en7div, 
                    out7divrsel_p=out7divrsel, ph7adjc_p=ph7adjc,
                    adlock_p=adlock,lockc_p=lockc, lockw_p=lockw
                    );

    //###############################################################
    // config8
    //###############################################################
    // [27:26]: R/W: outbufsel8yx[1:0]
    // [25:24]: R/W: cmosmode8nyx[1:0]
    // [23:22]: R/W: cmosmode8pyx[1:0]
    // [21]: R/W: pecl8hiswing[0]
    // [20]: R/W: en8div[0]
    // [19:13]: R/W: out8divrsel[6:0]
    // [12:6]: R/W: ph8adjc[6:0]
    // [5]: R/W: vcxoinvbb[0]
    // [4]: R/W: vcxotermsel[0]
    // [3]: R/W: vcxohysten[0]
    // [2]: R/W: vcxoacdcsel[0]
    // [1:0]: R/W: vcxobufselyx[1:0]
    outbufsel8yx = parseInt('01',2);// disable output8
    cmosmode8nyx = parseInt('10',2);// disable output8
    cmosmode8pyx = parseInt('10',2);// disable output8
    pecl8hiswing = 0;//0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en89div = 0;//0: divider is disabled on output8/9, 1: otherwise
    out8divrsel = parseInt('0000000',2);
    ph8adjc = parseInt('0000000',2);
    vcxoinvbb = 0;
    vcxotermsel = 0;
    vcxohysten = 1;
    vcxoacdcsel = 0;
    vcxobufselyx = parseInt('01',2); // VCXO and AUX Input Buffer Type Select (LVPECL,LVDS or LVCMOS): 01: LVPECL, 11: LVDS, 00: CMOS

    cdce_set_config8(
                    outbufsel8yx_p=outbufsel8yx,cmosmode8nyx_p=cmosmode8nyx,
                    cmosmode8pyx_p=cmosmode8pyx,pecl8hiswing_p=pecl8hiswing,en89div_p=en89div, 
                    out8divrsel_p=out8divrsel, ph8adjc_p=ph8adjc,
                    vcxoinvbb_p=vcxoinvbb,vcxotermsel_p=vcxotermsel,
                    vcxohysten_p=vcxohysten,vcxoacdcsel_p=vcxoacdcsel,vcxobufselyx_p=vcxobufselyx
                    );

    //###############################################################
    // config9
    //###############################################################
    // [27:26]: R/W: outbufsel9yx[1:0]
    // [25:24]: R/W: cmosmode9nyx[1:0]
    // [23:22]: R/W: cmosmode9pyx[1:0]
    // [21]: R/W: pecl9hiswing[0]
    // [20]: R/W: dis_aux_y9[0]
    // [19]: R/W: auxinvbb[0]
    // [18:17]: R/W: bias_div89[1:0]
    // [16:15]: R/W: bias_div_fb[1:0]
    // [14]: R/W: npreset_mdiv[0]
    // [13]: R/W: low_fd_fb_en[0]
    // [12]: R/W: pll_lock_bp[0]
    // [11]: R/W: indet_bp[0]
    // [10]: R/W: start_bypass[0]
    // [9]: R/W: divsync_dis[0]
    // [8]: R/W: noinv_reshol_int[0]
    // [7:6]: R/W: lockw32[1:0] 
    // [5:4]: R/W: hold_cnt[1:0]
    // [3]: R/W: holdtr[0]
    // [2]: R/W: hold_n[0]
    // [0]: R/W: holdf[0]
    outbufsel9yx = parseInt('01',2);// disable output9
    cmosmode9nyx = parseInt('10',2);// disable output9
    cmosmode9pyx = parseInt('10',2);// disable output9
    pecl9hiswing = 0;//0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    dis_aux_y9 = 0;
    auxinvbb = 0;
    bias_div89 = parseInt('00',2);
    bias_div_fb = parseInt('00',2);
    npreset_mdiv = 1;// 1: M-Divider NOT preseted by NHOLD, 0:M-Divider uses NHOLD as NPRESET
    low_fd_fb_en = 0;
    pll_lock_bp = 1;
    indet_bp = 0;
    start_bypass = 0; // When set to 0, START-Signal is synchronized to VCXO-Clock,  When set to 1, START-Sync Block is bypassed
    divsync_dis = 0;
    noinv_reshol_int = 0;
    lockw32 = parseInt('11',2); // Extended Lock-detect window => 19.3 ns
    hold_cnt = parseInt('00',2);
    holdtr = 1;
    hold_n = 1;
    holdf = 0;

    cdce_set_config9(
                    outbufsel9yx_p=outbufsel9yx,cmosmode9nyx_p=cmosmode9nyx,
                    cmosmode9pyx_p=cmosmode9pyx,pecl9hiswing_p=pecl9hiswing,dis_aux_y9_p=dis_aux_y9, 
                    auxinvbb_p=auxinvbb, bias_div89_p=bias_div89,bias_div_fb_p=bias_div_fb,
                    npreset_mdiv_p=npreset_mdiv,low_fd_fb_en_p=low_fd_fb_en,pll_lock_bp_p=pll_lock_bp,
                    indet_bp_p=indet_bp,start_bypass_p=start_bypass,divsync_dis_p=divsync_dis,noinv_reshol_int_p=noinv_reshol_int,
                    lockw32_p=lockw32,hold_cnt_p=hold_cnt,
                    holdtr_p=holdtr,hold_n_p=hold_n,holdf_p=holdf
                    );

    //###############################################################
    // config10
    //###############################################################
    // [27:14]: R/W: div_m[13:0]
    // [13:0]: R/W: div_n[13:0]
    div_n = parseInt('00000101111111',2); // VCXO Divider N (382)
    div_m = parseInt('00001001110000',2); // Reference Divider M (624)
    cdce_set_config10(
                    div_n_p= div_n,
                    div_m_p= div_m
                     );

    //###############################################################
    // config11
    //###############################################################
    // [26]: R/W: eplock[0]
    // [25]: R/W: reset_hold_mode[0]
    // [24]: R/W: sel_del1[0]
    // [23]: R/W: nreshape1[0]
    // [22]: R/W: fb_sel[0]
    // [21]: R/W: out_mux_sel[0]
    // [20]: R/W: fb_mux_sel[0]
    // [19]: R/W: pd_pll[0]
    // [18:12]: R/W: fb_phase[6:0]
    // [11:5]: R/W: fb_count32[6:0]
    // [4]: R/W: fb_inclk_inv[0]
    // [3]: R/W: fb_cml_sel[0]
    // [2]: R/W: fb_dis[0]
    // [1]: R/W: sec_div2[0]
    // [0]: R/W: pri_div2[0]
    eplock = 0;
    reset_hold_mode = 0; // f set to 1 the RESET or HOLD pin acts as HOLD, set to 0 it acts as RESET
    sel_del1 = 0; // If set to 0 it enables short delay for fast operation, If Set to 1 Long Delay recommended for Input References below 150Mhz
    nreshape1 = 0;
    fb_sel = 0; // Feed Back Path Selects FB/VCXO-Path when set to 0 (TI Test-GTME), The econdary Reference clock input is selected when set to 1 (TI Test-GTME)
    out_mux_sel = 0;// if Set to 0 it selects the VCXO Clock and if Set to 1 it selects the AUX Clock
    fb_mux_sel = 0; //0: VCXO clock is selected from (clock tree, FB-DIV and Det), 1: AUX clock is selected
    pd_pll = 0; //0: PLL in normal mode, 1: PLL is powered down
    fb_phase = parseInt('0000000',2); // Feedback Phase Adjust Bit0
    fb_count32 = parseInt('0000010',2); // Feedback Counter: divided by 2
    fb_inclk_inv= 0;
    fb_cml_sel= 0;
    fb_dis= 0;
    sec_div2= 0;// of set to 1 enables Secondary Reference Divide by 2, 0: otherwise divided by 1 => PRI_REF: 100 MHz -> 100 MHz.
    pri_div2= 0;// if set to 1 enables Primary Reference Divide by 2,  0: otherwise divided by 1

    cdce_set_config11(
                    eplock_p=eplock,reset_hold_mode_p=reset_hold_mode,sel_del1_p=sel_del1,
                    nreshape1_p=nreshape1, fb_sel_p=fb_sel, out_mux_sel_p=out_mux_sel, fb_mux_sel_p=fb_mux_sel,
                    pd_pll_p=pd_pll,fb_phase_p=fb_phase,fb_count32_p=fb_count32,fb_inclk_inv_p=fb_inclk_inv,
                    fb_cml_sel_p=fb_cml_sel,fb_dis_p=fb_dis,sec_div2_p=sec_div2,pri_div2_p=pri_div2
                     );

    //###############################################################
    // config12
    //###############################################################
    // [26]: R/W: secactivity[0]
    // [25]: R/W: priactivity[0]
    // [24:21]: R/W: titstcfg[3:0]
    // [20:17]: R/W: status[3:0]
    // [15]: R/W: shold[0]
    // [14]: R/W: sxoiref[0]
    // [13]: R/W: pd_io[0]
    // [12:10]: R/W: revision[2:0]
    // [9]: R/W: gtme[0]
    // [8]: R/W: reset_hold_n[0]
    // [7]: R/W: sleep_n[0]
    // [6]: R: pll_lock[0]
    // [5]: R: indet_vcxo[0]
    // [4]: R: indet_aux[0]
    secactivity= 0;
    priactivity = 0;
    titstcfg = parseInt('0000',2);
    status = parseInt('0000',2);
    shold = 0;
    sxoiref = 0;
    pd_io = 0;
    revision = parseInt('000',2);
    gtme = 0;
    reset_hold_n = 1;
    sleep_n = 1;
    pll_lock = 0;
    indet_vcxo = 0;
    indet_aux = 0;

    cdce_set_config12(
                    secactivity_p = secactivity,priactivity_p=priactivity,titstcfg_p=titstcfg,
                    status_p=status,
                    shold_p=shold,sxoiref_p=sxoiref,pd_io_p=pd_io,
                    revision_p=revision,gtme_p=gtme, reset_hold_n_p=reset_hold_n,
                    sleep_n_p=sleep_n,pll_lock_p=pll_lock,indet_vcxo_p=indet_vcxo,indet_aux_p=indet_aux
                     );
    





    }
	
	
	
	//###############################################################
// Configure the CDCE72010 Device
//###############################################################
function CDCE72010_configure_100M(verbosity_p)
    {

	if (typeof(verbosity_p)==='undefined') verbosity_p = 0;

    cdce_init_device();

    //###############################################################
    // config0
    //###############################################################
    // [27:26]: R/W: outbufsel0yx[1:0]
    // [25:24]: R/W: cmosmode0nyx[1:0]
    // [23:22]: R/W: cmosmode0pyx[1:0]
    // [21]: R/W: pecl0hiswing[0]
    // [20]: R/W: irefres[0]
    // [17:14]: R/W: icp[3:0]
    // [13]: R/W: cp_pre[0]
    // [12]: R/W: cp_opa[0]
    // [11]: R/W: cp_snk[0]
    // [10]: R/W: cp_src[0]
    // [9]: R/W: cp_dir[0]
    // [7:6]: R/W: delay_pfd[1:0]
    // [5]: R/W: refselcntrl[0]
    // [4]: R/W: vcxosel[0]
    // [3]: R/W: secsel[0]
    // [2]: R/W: prisel[0]
    // [1:0]: R/W: inbufselyx[1:0]

    outbufsel0yx = parseInt('01',2); // disable output0
    cmosmode0nyx = parseInt('10',2); // disable output0
    cmosmode0pyx = parseInt('10',2); // disable output0
    pecl0hiswing = 0; //0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    irefres = 0;
    icp = parseInt('1111',2);
    cp_pre = 0; // Preset charge pump output voltage to VCC_CP/2, on [1], off [0] 
    cp_opa = 0;
    cp_snk = 0;
    cp_src = 0;
    cp_dir = 0;
    delay_pfd = parseInt('00',2); // delay on the reset path: 1.5 ns (default)
    refselcntrl = 1;// 1: use register0 to select ref_clk
    vcxosel = 1; // 0; use register0 to select ref_clk, 1: use VCXO/AUX-clock
    secsel = 0; // use prim_ref
    prisel = 1;
    inbufselyx = parseInt('11',2);//LVDS PRI_Ref/SEC_Ref

    cdce_set_config0(
                    outbufsel0yx_p=outbufsel0yx,cmosmode0nyx_p = cmosmode0nyx,
                    cmosmode0pyx_p = cmosmode0pyx,pecl0hiswing_p = pecl0hiswing,irefres_p=irefres,
                    icp_p=icp,cp_pre_p=cp_pre, cp_opa_p=cp_opa,
                    cp_snk_p=cp_snk,cp_src_p=cp_src,cp_dir_p=cp_dir,
                    delay_pfd_p=delay_pfd,refselcntrl_p=refselcntrl,vcxosel_p=vcxosel,
                    secsel_p=secsel,prisel_p=prisel,inbufselyx_p=inbufselyx
              );

    //###############################################################
    // config1
    //###############################################################
    // [27:26]: R/W: outbufsel1yx[1:0]
    // [25:24]: R/W: cmosmode1nyx[1:0]
    // [23:22]: R/W: cmosmode1pyx[1:0]
    // [21]: R/W: pecl1hiswing[0]
    // [20]: R/W: en01div[0]
    // [19:13]: R/W: out1divrsel[6:0]
    // [12:6]: R/W: ph1adjc[6:0]
    // [5]: R/W: failsafe[0]
    // [4]: R/W: secinvbb[0]
    // [3]: R/W: priinvbb[0]
    // [2]: R/W: termsel[0]
    // [1]: R/W: hysten[0]
    // [0]: R/W: acdcsel[0]

    outbufsel1yx = parseInt('01',2); // disable output1
    cmosmode1nyx = parseInt('10',2); // disable output1
    cmosmode1pyx = parseInt('10',2); // disable output1
    pecl1hiswing = 0; //0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en01div = 0; //0: divider is disabled on output0/output1
    out1divrsel = parseInt('000_0000',2);
    ph1adjc = parseInt('000_0000',2);
    failsafe = 0;
    secinvbb = 0;
    priinvbb = 0;
    termsel = 0; 
    hysten = 1;
    acdcsel = 0;

    cdce_set_config1(
                    outbufsel1yx_p=outbufsel1yx,cmosmode1nyx_p=cmosmode1nyx,
                    cmosmode1pyx_p=cmosmode1pyx,pecl1hiswing_p=pecl1hiswing,en01div_p=en01div, 
                    out1divrsel_p=out1divrsel, ph1adjc_p=ph1adjc,
                    failsafe_p=failsafe,secinvbb_p=secinvbb,
                    priinvbb_p=priinvbb,termsel_p=termsel,hysten_p=hysten,acdcsel_p=acdcsel
                    );

    //###############################################################
    // config2
    //###############################################################
    // [27:26]: R/W: outbufsel2yx[1:0]
    // [25:24]: R/W: cmosmode2nyx[1:0]
    // [23:22]: R/W: cmosmode2pyx[1:0]
    // [21]: R/W: pecl2hiswing[0]
    // [20]: R/W: en2div[0]
    // [19:13]: R/W: out2divrsel[6:0]
    // [12:6]: R/W: ph2adjc[6:0]
    // [5:3]: R/W: dlyn[2:0]
    // [2:0]: R/W: dlym[2:0]
    outbufsel2yx = parseInt('10',2); // LVPECL output2
    cmosmode2nyx = parseInt('00',2); // LVPECL output2
    cmosmode2pyx = parseInt('00',2); // LVPECL output2
    pecl2hiswing = 1; //0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en2div = 1; //0: divider is disabled on output2, 1: otherwise
    out2divrsel = parseInt('1000000',2); // Output Divider 2 ratio select: divided by 2
    ph2adjc = parseInt('0000000',2);
    dlyn = parseInt('00',2); // Feedback phase delay. (default:'00' <=> 0ps (page 55)).If Progr Delay N is set, all Yx outputs are leading to the Reference Clock according to the value set
    dlym = parseInt('00',2);// Reference phase delay. (default:'00' <=> 0ps (page 55)). If Progr Delay M is set, all Yx outputs are lagging to the Reference Clock according to the value set

    cdce_set_config2(
                    outbufsel2yx_p=outbufsel2yx,cmosmode2nyx_p=cmosmode2nyx,
                    cmosmode2pyx_p=cmosmode2pyx,pecl2hiswing_p=pecl2hiswing,en2div_p=en2div, 
                    out2divrsel_p=out2divrsel, ph2adjc_p=ph2adjc,
                    dlyn_p=dlyn,dlym_p=dlym
                    );

    //###############################################################
    // config3
    //###############################################################
    // [27:26]: R/W: outbufsel3yx[1:0]
    // [25:24]: R/W: cmosmode3nyx[1:0]
    // [23:22]: R/W: cmosmode3pyx[1:0]
    // [21]: R/W: pecl3hiswing[0]
    // [20]: R/W: en3div[0]
    // [19:13]: R/W: out3divrsel[6:0]
    // [12:6]: R/W: ph3adjc[6:0]
    // [5:4]: R/W: bias_div23[1:0]
    // [3:2]: R/W: bias_div01[1:0]
    // [1]: R/W: dis_fdet_fb[0]
    // [0]: R/W: dis_fdet_ref[0]

    outbufsel3yx = parseInt('01',2);// disable output3
    cmosmode3nyx = parseInt('10',2);// disable output3
    cmosmode3pyx = parseInt('10',2);// disable output3
    pecl3hiswing = 0;//0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en3div = 0;//0: divider is disabled on output3, 1: otherwise
    out3divrsel = parseInt('0000000',2);
    ph3adjc = parseInt('0000000',2);
    bias_div23 = parseInt('00',2);
    bias_div01 = parseInt('00',2);
    dis_fdet_fb = 0;
    dis_fdet_ref = 0;// 0: ref clock frequency detector is ON, 1: otherwise

    cdce_set_config3(
                    outbufsel3yx_p=outbufsel3yx,cmosmode3nyx_p=cmosmode3nyx,
                    cmosmode3pyx_p=cmosmode3pyx,pecl3hiswing_p=pecl3hiswing,en3div_p=en3div, 
                    out3divrsel_p=out3divrsel, ph3adjc_p=ph3adjc,
                    bias_div23_p=bias_div23,
                    bias_div01_p=bias_div01, dis_fdet_fb_p=dis_fdet_fb,dis_fdet_ref_p=dis_fdet_ref
                    );

    //###############################################################
    // config4
    //###############################################################
    // [27:26]: R/W: outbufsel4yx[1:0]
    // [25:24]: R/W: cmosmode4nyx[1:0]
    // [23:22]: R/W: cmosmode4pyx[1:0]
    // [21]: R/W: pecl4hiswing[0]
    // [20]: R/W: en4div[0]
    // [19:13]: R/W: out4divrsel[6:0]
    // [12:6]: R/W: ph4adjc[6:0]
    // [4]: R/W: holdonlor[0]

    outbufsel4yx = parseInt('11',2); // LVDS output4
    cmosmode4nyx = parseInt('10',2); // LVDS output4
    cmosmode4pyx = parseInt('10',2); // LVDS output4
    pecl4hiswing = 0;//0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en4div = 1;//0: divider is disabled on output4, 1: otherwise
    out4divrsel = parseInt('1000000',2); // Output Divider 4 ratio select: divided by 2
    ph4adjc = parseInt('000_0000',2);
    holdonlor = 0;//If set to 0, CP remains active and will discharge loop filter if input reference clock is lost

    cdce_set_config4(
                    outbufsel4yx_p=outbufsel4yx,cmosmode4nyx_p=cmosmode4nyx,
                    cmosmode4pyx_p=cmosmode4pyx,pecl4hiswing_p=pecl4hiswing,en4div_p=en4div, 
                    out4divrsel_p=out4divrsel, ph4adjc_p=ph4adjc,
                    holdonlor_p=holdonlor
                    );

    //###############################################################
    // config5
    //###############################################################
    // [27:26]: R/W: outbufsel5yx[1:0]
    // [25:24]: R/W: cmosmode5nyx[1:0]
    // [23:22]: R/W: cmosmode5pyx[1:0]
    // [21]: R/W: pecl5hiswing[0]
    // [20]: R/W: en5div[0]
    // [19:13]: R/W: out5divrsel[6:0]
    // [12:6]: R/W: ph5adjc[6:0]
    // [3:2]: R/W: bias_div67[1:0]
    // [1:0]: R/W: bias_div45[1:0]
    outbufsel5yx = parseInt('01',2); // disable output5
    cmosmode5nyx = parseInt('10',2); // disable output5
    cmosmode5pyx = parseInt('10',2); // disable output5
    pecl5hiswing = 0; //0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en5div = 0; //0: divider is disabled on output5, 1: otherwise
    out5divrsel = parseInt('0000000',2);
    ph5adjc = parseInt('0000000',2);
    bias_div67 = parseInt('00',2);//00, No current reduction for all output-divider
    bias_div45 = parseInt('00',2);//00, No current reduction for all output-divider


    cdce_set_config5(
                    outbufsel5yx_p=outbufsel5yx,cmosmode5nyx_p=cmosmode5nyx,
                    cmosmode5pyx_p=cmosmode5pyx,pecl5hiswing_p=pecl5hiswing,en5div_p=en5div, 
                    out5divrsel_p=out5divrsel, ph5adjc_p=ph5adjc,
                    bias_div67_p=bias_div67,bias_div45_p=bias_div45
                    );

    //###############################################################
    // config6
    //###############################################################
    // [27:26]: R/W: outbufsel6yx[1:0]
    // [25:24]: R/W: cmosmode6nyx[1:0]
    // [23:22]: R/W: cmosmode6pyx[1:0]
    // [21]: R/W: pecl6hiswing[0]
    // [20]: R/W: en6div[0]
    // [19:13]: R/W: out6divrsel[6:0]
    // [12:6]: R/W: ph6adjc[6:0]
    // [5]: R/W: det_start_bypass[0]
    // [4]: R/W: fb_start_bypass[0]
    // [3]: R/W: fbdeterm_div2_dis[0]
    // [2]: R/W: fbdeterm_div_sel[0]
    // [0]: R/W: fb_fd_desel[0]
    outbufsel6yx = parseInt('01',2);// disable output6
    cmosmode6nyx = parseInt('10',2);// disable output6
    cmosmode6pyx = parseInt('10',2);// disable output6
    pecl6hiswing = 0;//0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en6div = 0;//0: divider is disabled on output6, 1: otherwise
    out6divrsel = parseInt('0000000',2);
    ph6adjc = parseInt('0000000',2);
    det_start_bypass = 0; // 0: Output-Dividers started with delay block (RC), normal operation, 1:Output-Dividers can be started with external NRESET-signal (pin)
    fb_start_bypass = 0;
    fbdeterm_div2_dis = 0;
    fbdeterm_div_sel = 0;
    fb_fd_desel = 0;

    cdce_set_config6(
                    outbufsel6yx_p=outbufsel6yx,cmosmode6nyx_p=cmosmode6nyx,
                    cmosmode6pyx_p=cmosmode6pyx,pecl6hiswing_p=pecl6hiswing,en6div_p=en6div, 
                    out6divrsel_p=out6divrsel, ph6adjc_p=ph6adjc,
                    det_start_bypass_p=det_start_bypass,fb_start_bypass_p=fb_start_bypass,
                    fbdeterm_div2_dis_p=fbdeterm_div2_dis,fbdeterm_div_sel_p=fbdeterm_div_sel,fb_fd_desel_p=fb_fd_desel
                    );

    //###############################################################
    // config7
    //###############################################################
    // [27:26]: R/W: outbufsel7yx[1:0]
    // [25:24]: R/W: cmosmode7nyx[1:0]
    // [23:22]: R/W: cmosmode7pyx[1:0]
    // [21]: R/W: pecl7hiswing[0]
    // [20]: R/W: en7div[0]
    // [19:13]: R/W: out7divrsel[6:0]
    // [12:6]: R/W: ph7adjc[6:0]
    // [5]: R/W: adlock[0]
    // [4:3]: R/W: lockc[1:0]
    // [1:0]: R/W: lockw[1:0]
    outbufsel7yx = parseInt('10',2);// LVPECL output7
    cmosmode7nyx = parseInt('00',2);// LVPECL output7
    cmosmode7pyx = parseInt('00',2);// LVPECL output7
    pecl7hiswing = 1;//0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en7div = 1;//0: divider is disabled on output7, 1: otherwise
    out7divrsel = parseInt('1000000',2); // Output Divider 7 ratio select: divided by 2
    ph7adjc = parseInt('0000000',2);
    adlock = 0;
    lockc = parseInt('00',2); // Number of coherent lock events (page 59) ("00": default : 1 successive lock event)
    lockw = parseInt('01',2); // Lock-detect window (default : 01)

    cdce_set_config7(
                    outbufsel7yx_p=outbufsel7yx,cmosmode7nyx_p=cmosmode7nyx,
                    cmosmode7pyx_p=cmosmode7pyx,pecl7hiswing_p=pecl7hiswing,en7div_p=en7div, 
                    out7divrsel_p=out7divrsel, ph7adjc_p=ph7adjc,
                    adlock_p=adlock,lockc_p=lockc, lockw_p=lockw
                    );

    //###############################################################
    // config8
    //###############################################################
    // [27:26]: R/W: outbufsel8yx[1:0]
    // [25:24]: R/W: cmosmode8nyx[1:0]
    // [23:22]: R/W: cmosmode8pyx[1:0]
    // [21]: R/W: pecl8hiswing[0]
    // [20]: R/W: en8div[0]
    // [19:13]: R/W: out8divrsel[6:0]
    // [12:6]: R/W: ph8adjc[6:0]
    // [5]: R/W: vcxoinvbb[0]
    // [4]: R/W: vcxotermsel[0]
    // [3]: R/W: vcxohysten[0]
    // [2]: R/W: vcxoacdcsel[0]
    // [1:0]: R/W: vcxobufselyx[1:0]
    outbufsel8yx = parseInt('01',2);// disable output8
    cmosmode8nyx = parseInt('10',2);// disable output8
    cmosmode8pyx = parseInt('10',2);// disable output8
    pecl8hiswing = 0;//0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    en89div = 0;//0: divider is disabled on output8/9, 1: otherwise
    out8divrsel = parseInt('0000000',2);
    ph8adjc = parseInt('0000000',2);
    vcxoinvbb = 0;
    vcxotermsel = 0;
    vcxohysten = 1;
    vcxoacdcsel = 0;
    vcxobufselyx = parseInt('01',2); // VCXO and AUX Input Buffer Type Select (LVPECL,LVDS or LVCMOS): 01: LVPECL, 11: LVDS, 00: CMOS

    cdce_set_config8(
                    outbufsel8yx_p=outbufsel8yx,cmosmode8nyx_p=cmosmode8nyx,
                    cmosmode8pyx_p=cmosmode8pyx,pecl8hiswing_p=pecl8hiswing,en89div_p=en89div, 
                    out8divrsel_p=out8divrsel, ph8adjc_p=ph8adjc,
                    vcxoinvbb_p=vcxoinvbb,vcxotermsel_p=vcxotermsel,
                    vcxohysten_p=vcxohysten,vcxoacdcsel_p=vcxoacdcsel,vcxobufselyx_p=vcxobufselyx
                    );

    //###############################################################
    // config9
    //###############################################################
    // [27:26]: R/W: outbufsel9yx[1:0]
    // [25:24]: R/W: cmosmode9nyx[1:0]
    // [23:22]: R/W: cmosmode9pyx[1:0]
    // [21]: R/W: pecl9hiswing[0]
    // [20]: R/W: dis_aux_y9[0]
    // [19]: R/W: auxinvbb[0]
    // [18:17]: R/W: bias_div89[1:0]
    // [16:15]: R/W: bias_div_fb[1:0]
    // [14]: R/W: npreset_mdiv[0]
    // [13]: R/W: low_fd_fb_en[0]
    // [12]: R/W: pll_lock_bp[0]
    // [11]: R/W: indet_bp[0]
    // [10]: R/W: start_bypass[0]
    // [9]: R/W: divsync_dis[0]
    // [8]: R/W: noinv_reshol_int[0]
    // [7:6]: R/W: lockw32[1:0] 
    // [5:4]: R/W: hold_cnt[1:0]
    // [3]: R/W: holdtr[0]
    // [2]: R/W: hold_n[0]
    // [0]: R/W: holdf[0]
    outbufsel9yx = parseInt('11',2);// LVDS output9
    cmosmode9nyx = parseInt('10',2);// LVDS output9
    cmosmode9pyx = parseInt('10',2);// LVDS output9
    pecl9hiswing = 0;//0: no High output voltage swing in LVPECL/LVDS mode, 1: otherwise
    dis_aux_y9 = 0;
    auxinvbb = 0;
    bias_div89 = parseInt('00',2);
    bias_div_fb = parseInt('00',2);
    npreset_mdiv = 1;// 1: M-Divider NOT preseted by NHOLD, 0:M-Divider uses NHOLD as NPRESET
    low_fd_fb_en = 0;
    pll_lock_bp = 1;
    indet_bp = 0;
    start_bypass = 0; // When set to 0, START-Signal is synchronized to VCXO-Clock,  When set to 1, START-Sync Block is bypassed
    divsync_dis = 0;
    noinv_reshol_int = 0;
    lockw32 = parseInt('11',2); // Extended Lock-detect window => 19.3 ns
    hold_cnt = parseInt('00',2);
    holdtr = 1;
    hold_n = 1;
    holdf = 0;

    cdce_set_config9(
                    outbufsel9yx_p=outbufsel9yx,cmosmode9nyx_p=cmosmode9nyx,
                    cmosmode9pyx_p=cmosmode9pyx,pecl9hiswing_p=pecl9hiswing,dis_aux_y9_p=dis_aux_y9, 
                    auxinvbb_p=auxinvbb, bias_div89_p=bias_div89,bias_div_fb_p=bias_div_fb,
                    npreset_mdiv_p=npreset_mdiv,low_fd_fb_en_p=low_fd_fb_en,pll_lock_bp_p=pll_lock_bp,
                    indet_bp_p=indet_bp,start_bypass_p=start_bypass,divsync_dis_p=divsync_dis,noinv_reshol_int_p=noinv_reshol_int,
                    lockw32_p=lockw32,hold_cnt_p=hold_cnt,
                    holdtr_p=holdtr,hold_n_p=hold_n,holdf_p=holdf
                    );

    //###############################################################
    // config10
    //###############################################################
    // [27:14]: R/W: div_m[13:0]
    // [13:0]: R/W: div_n[13:0]
    div_n = 0x0; // VCXO Divider N (382)
    div_m = 0x0; // Reference Divider M (624)
    cdce_set_config10(
                    div_n_p= div_n,
                    div_m_p= div_m
                     );

    //###############################################################
    // config11
    //###############################################################
    // [26]: R/W: eplock[0]
    // [25]: R/W: reset_hold_mode[0]
    // [24]: R/W: sel_del1[0]
    // [23]: R/W: nreshape1[0]
    // [22]: R/W: fb_sel[0]
    // [21]: R/W: out_mux_sel[0]
    // [20]: R/W: fb_mux_sel[0]
    // [19]: R/W: pd_pll[0]
    // [18:12]: R/W: fb_phase[6:0]
    // [11:5]: R/W: fb_count32[6:0]
    // [4]: R/W: fb_inclk_inv[0]
    // [3]: R/W: fb_cml_sel[0]
    // [2]: R/W: fb_dis[0]
    // [1]: R/W: sec_div2[0]
    // [0]: R/W: pri_div2[0]
    eplock = 0;
    reset_hold_mode = 0; // f set to 1 the RESET or HOLD pin acts as HOLD, set to 0 it acts as RESET
    sel_del1 = 0; // If set to 0 it enables short delay for fast operation, If Set to 1 Long Delay recommended for Input References below 150Mhz
    nreshape1 = 0;
    fb_sel = 0; // Feed Back Path Selects FB/VCXO-Path when set to 0 (TI Test-GTME), The econdary Reference clock input is selected when set to 1 (TI Test-GTME)
    out_mux_sel = 0;// if Set to 0 it selects the VCXO Clock and if Set to 1 it selects the AUX Clock
    fb_mux_sel = 0; //0: VCXO clock is selected from (clock tree, FB-DIV and Det), 1: AUX clock is selected
    pd_pll = 0; //0: PLL in normal mode, 1: PLL is powered down
    fb_phase = parseInt('0000000',2); // Feedback Phase Adjust Bit0
    fb_count32 = parseInt('000000',2); // Feedback Counter: divided by 1
    fb_inclk_inv= 0;
    fb_cml_sel= 0;
    fb_dis= 0;
    sec_div2= 0;// of set to 1 enables Secondary Reference Divide by 2, 0: otherwise divided by 1 => PRI_REF: 100 MHz -> 100 MHz.
    pri_div2= 0;// if set to 1 enables Primary Reference Divide by 2,  0: otherwise divided by 1

    cdce_set_config11(
                    eplock_p=eplock,reset_hold_mode_p=reset_hold_mode,sel_del1_p=sel_del1,
                    nreshape1_p=nreshape1, fb_sel_p=fb_sel, out_mux_sel_p=out_mux_sel, fb_mux_sel_p=fb_mux_sel,
                    pd_pll_p=pd_pll,fb_phase_p=fb_phase,fb_count32_p=fb_count32,fb_inclk_inv_p=fb_inclk_inv,
                    fb_cml_sel_p=fb_cml_sel,fb_dis_p=fb_dis,sec_div2_p=sec_div2,pri_div2_p=pri_div2
                     );

    //###############################################################
    // config12
    //###############################################################
    // [26]: R/W: secactivity[0]
    // [25]: R/W: priactivity[0]
    // [24:21]: R/W: titstcfg[3:0]
    // [20:17]: R/W: status[3:0]
    // [15]: R/W: shold[0]
    // [14]: R/W: sxoiref[0]
    // [13]: R/W: pd_io[0]
    // [12:10]: R/W: revision[2:0]
    // [9]: R/W: gtme[0]
    // [8]: R/W: reset_hold_n[0]
    // [7]: R/W: sleep_n[0]
    // [6]: R: pll_lock[0]
    // [5]: R: indet_vcxo[0]
    // [4]: R: indet_aux[0]
    secactivity= 0;
    priactivity = 0;
    titstcfg = parseInt('0000',2);
    status = parseInt('0000',2);
    shold = 0;
    sxoiref = 0;
    pd_io = 0;
    revision = parseInt('000',2);
    gtme = 0;
    reset_hold_n = 1;
    sleep_n = 1;
    pll_lock = 0;
    indet_vcxo = 0;
    indet_aux = 0;

    cdce_set_config12(
                    secactivity_p = secactivity,priactivity_p=priactivity,titstcfg_p=titstcfg,
                    status_p=status,
                    shold_p=shold,sxoiref_p=sxoiref,pd_io_p=pd_io,
                    revision_p=revision,gtme_p=gtme, reset_hold_n_p=reset_hold_n,
                    sleep_n_p=sleep_n,pll_lock_p=pll_lock,indet_vcxo_p=indet_vcxo,indet_aux_p=indet_aux
                     );
    





    }