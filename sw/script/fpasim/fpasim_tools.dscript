// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                   fpasim_tools.dscript
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference    
// -------------------------------------------------------------------------------------------------------------
//    @details                
//
// -------------------------------------------------------------------------------------------------------------
include("./fpasim/CDCE72010.dscript")
include("./fpasim/ADS62P49.dscript")
include("./fpasim/DAC3283.dscript")
include("./fpasim/AMC7823.dscript")



/**
 * Display the essential parameters of the test.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_script_info(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    /*
     Print the test info
    */
    msg = "Script info:";
    display_title(msg_p = msg, level_p = level0, mode_p = mode_p);

    // get the operator name
    operator_name = get_operator_name();
    msg = "Operator Name: " + operator_name;
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    // get the session
    session_name = get_session_name();
    msg = "Session: " + session_name;
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    // Print the current date
    date = maDate()
    msg = "Date: " + date;
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    // get board id
    reg_name = 'BOARD_ID';
    msg = reg_name + ": ";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);
    data = fpasim_get_wireout_by_name(reg_name_p = reg_name, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    // get firmware id
    reg_name = 'FIRMWARE_ID';
    msg = reg_name + ": ";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);
    data = fpasim_get_wireout_by_name(reg_name_p = reg_name, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    // get firmware version
    reg_name = 'FIRMWARE_VERSION';
    msg = reg_name + ": ";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);
    data = fpasim_get_wireout_by_name(reg_name_p = reg_name, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

}

/**
 * Reset the fpasim function.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_reset(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    // Reset: CTRL
    msg = "Set CTRL: Reset On"
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    rst = 1;
    en = 0;
    // build the data to send
    data = fpasim_build_ctrl(rst_p = rst, en_p = en);
    sendToFPA_configureControl(data);
    //fpasim_set_debug_wirein_by_name(reg_name_p = 'CTRL', data_p = data, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
    msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);


    // Reset SPI_CTRL
    msg = "Set SPI_CTRL: Reset On"
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    rst = 1;
    en = 0;
    // build the data to send
    data = fpasim_build_spi_ctrl(rst_p = rst, en_p = en);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'SPI_CTRL', data_p = data, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    // Reset DEBUG_CTRL
    msg = "Set DEBUG_CTRL: Reset On"
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    rst_status = 1;
    debug_pulse = 0;
    // build the data to send
    data = fpasim_build_debug_ctrl(rst_status_p = rst_status, debug_pulse_p = debug_pulse);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'DEBUG_CTRL', data_p = data, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    // Set tempo: 
    msg = "Set tempo"
    display(msg_p = msg, level_p = level0, mode_p = mode_p);
    msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);
    waitMs(100);

    // Reset: CTRL
    msg = "Set CTRL: Reset Off"
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    rst = 0;
    en = 0;
    // build the data to send
    data = fpasim_build_ctrl(rst_p = rst, en_p = en);
    sendToFPA_configureControl(data);
    //fpasim_set_debug_wirein_by_name(reg_name_p = 'CTRL', data_p = data, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
    msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    // Reset SPI_CTRL
    msg = "Set SPI_CTRL: Reset Off"
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    rst = 0;
    en = 0;
    // build the data to send
    data = fpasim_build_spi_ctrl(rst_p = rst, en_p = en);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'SPI_CTRL', data_p = data, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    // Reset DEBUG_CTRL
    msg = "Set DEBUG_CTRL: Reset Off"
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    rst_status = 0;
    debug_pulse = 0;
    // build the data to send
    data = fpasim_build_debug_ctrl(rst_status_p = rst_status, debug_pulse_p = debug_pulse);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'DEBUG_CTRL', data_p = data, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
}


/**
 * Check if the specified error is equal to error_p. Then, display the result.
 * @param {number} error_id_p - error id. The range is [0;10].
 * @param {number} error_p - error value to compare.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_check_error_by_id(error_id_p, error_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const data1 = error_p;

    data0 = fpasim_get_error_by_id(sel_error_p = error_id_p, level_p = level0, mode_p = mode_p, verbosity_p = -2);
    str_data0 = convert_int_to_str_hex(value_p = data0, width_p = 32);
    str_data1 = convert_int_to_str_hex(value_p = data1, width_p = 32);
    const msg_error = "Errors" + error_id_p.toString(10) + ":";
    check_equal(value0_p = data0, value1_p = data1, msg_p = msg_error, level_p = level0, mode_p = mode_p);
}


/**
 * Check if all errors are equal to 0x0. Then, display the result of each check.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_check_all_errors(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;

    for (i = 0; i <= 10; i++) {
        fpasim_check_error_by_id(error_id_p = i, error_p = 0, level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);

    }

}


/**
 * Configure the SPI devices of the FMC150 boards.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} 0
 */
function configure_fmc150_spi_device(level_p, mode_p, verbosity_p) {

    CDCE72010_configure(level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);
    ADS62P49_configure(level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);
    DAC3283_configure(level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);
    AMC7823_configure(level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);

    return 0;

}

/**
 * Check if 2 values are equal. Then, display the result.
 * @param {number} value0_p - first value to compare.
 * @param {number} value1_p - 2nd  value to compare.
 * @param {string} msg_p - error message.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @return {number} 0
 */
function check_equal(value0_p, value1_p, msg_p, level_p, mode_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    const str_data0 = convert_int_to_str_hex(value_p = value0_p, width_p = 32);
    const str_data1 = convert_int_to_str_hex(value_p = value1_p, width_p = 32);

    if (value0_p !== value1_p) {
        const msg_tmp = "[KO]: " + msg_p;
        display(msg_p = msg_tmp, level_p = level0, mode_p = mode_p);

        const msg = "[check_equal]: value0_p: 0x" + str_data0 + " !=  value_1_p: 0x" + str_data1;
        display(msg_p = msg, level_p = level1, mode_p = mode_p);
    } else {
        const msg = "[OK]: " + msg_p;
        display(msg_p = msg, level_p = level0, mode_p = mode_p);

        const msg = "[check_equal]: value0_p: 0x" + str_data0 + " ==  value_1_p: 0x" + str_data1;
        display(msg_p = msg, level_p = level1, mode_p = mode_p);
    }
}

/**
 * Check if 2 tab are identical. Then, display the result.
 * @param {array of number} tab0_p - 1st tab.
 * @param {array of number} tab1_p - 2nd tab.
 * @param {string} msg_p - error message.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @return {number} 0
 */
function check_equal_tab(tab0_p, tab1_p, msg_p, level_p, mode_p)

{

    error = 0;

    for (i = 0; i <= tab0_p.length; i++) {
        value0 = tab0_p[i];
        value1 = tab1_p[i];

        if (value0 != value1) {
            msg = "index: " + i.toString(10) + " value0_p: " + value0.toString(10) + " ,value1_p:" + value1.toString(10);
            display(msg_p = msg, level_p = level_p, mode_p = mode_p);
            error = 1;
        }
    }

    check_equal(value0_p = error, value1_p = 0, msg_p = msg_p, level_p = level_p, mode_p = mode_p);

}

//---------------------------------------------------------------------------------------
// General functions
//---------------------------------------------------------------------------------------

/**
 * Display a popup menu with a pre-defined list of operators.
 * @return {string} Name of the operator.
 */
function get_operator_name() {
    OperatorTab = ["", "Ken", "David", "Odile", "Laurent", "Yann"]
    OperatorId = getItem("Please, select the operator name:", OperatorTab)
    if (OperatorId == -1) {
        Operator_name = getText("Please, type the operator name:", "")
    } else {
        Operator_name = OperatorTab[OperatorId]
    }
    return (Operator_name)
}

/**
 * Display a popup menu in order to define a session by the user.
 * @return {string} Name of the session.
 */
function get_session_name() {
    session_name = getText("Please, type the session name:", "Default_session_name");
    return (session_name);
}

/**
 * Format the current date.
 * @return {string} formatted date.
 */
function maDate()
// Returns the date using the format : yearmonthday_hourminutesecond
{
    d = new Date();
    Now_date = d.getFullYear() + (("00" + (d.getMonth() + 1).toString()).slice(-2)) + (("00" + (d.getDate()).toString()).slice(-2)) + "_" + (("00" + (d.getHours()).toString()).slice(-2)) + (("00" + (d.getMinutes()).toString()).slice(-2)) + (("00" + (d.getSeconds()).toString()).slice(-2));
    return Now_date;
}



//---------------------------------------------------------------------------------------