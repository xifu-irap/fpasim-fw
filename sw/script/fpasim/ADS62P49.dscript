// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                   ads62p49.py
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference
// -------------------------------------------------------------------------------------------------------------
//    @details
//
//   This javscript generates spi commands in order to initialize the ads62p49 (ADCs) registers.
//
//   Note:
//      . Tested with javascript
//
// -------------------------------------------------------------------------------------------------------------

// import libraries
include("./fpasim/utils_tools.dscript");
include("./fpasim/fpasim_address.dscript");
//include("./fpasim/fpasim_tools.dscript");

// define the SPI device registers
const ADC_ADDR = {};
ADC_ADDR['reg0'] = 0x00;
ADC_ADDR['reg1'] = 0x20;
ADC_ADDR['reg2'] = 0x3F;
ADC_ADDR['reg3'] = 0x40;
ADC_ADDR['reg4'] = 0x41;
ADC_ADDR['reg5'] = 0x44;
ADC_ADDR['reg6'] = 0x50;
ADC_ADDR['reg7'] = 0x51;
ADC_ADDR['reg8'] = 0x52;
ADC_ADDR['reg9'] = 0x53;
ADC_ADDR['reg10'] = 0x55;
ADC_ADDR['reg11'] = 0x57;
ADC_ADDR['reg12'] = 0x62;
ADC_ADDR['reg13'] = 0x63;
ADC_ADDR['reg14'] = 0x66;
ADC_ADDR['reg15'] = 0x68;
ADC_ADDR['reg16'] = 0x6A;
ADC_ADDR['reg17'] = 0x75;
ADC_ADDR['reg18'] = 0x76;

// verbosity min to display register access
const c_ADC_REG_VERBOSITY_MIN = 0;
// verbosity min to display (addr,data)
const c_ADC_ADDR_VERBOSITY_MIN = 1;
// verbosity min to display register bit
const c_ADC_BIT_VERBOSITY_MIN = c_ADC_ADDR_VERBOSITY_MIN + 1;

/*
FPGA specifics:
 Enable the FPGA SPI
*/
function adc_spi_enable(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;

    //---------------------------------------------------------------------
    //-- write in the SPI_CTRL register 
    //---------------------------------------------------------------------

    // reset the spi links
    // rst = 1;
    // en = 0;
    // data = (rst << 1) + en;
    // sendToFPA_debugSetWireIn(0x12,data);

    //---------------------------------------------------------------------
    //-- write in the SPI_CTRL register 
    //---------------------------------------------------------------------

    // en the spi links
    rst = 0;
    en = 1;
    data = (rst << 1) + en;
    addr = FPASIM_ADDR_WIREIN['SPI_CTRL'];
    sendToFPA_debugSetWireIn(addr, data);

    // fpasim_set_spi_ctrl(rst_p=rst, en_p=en, level_p=0, mode_p=0, verbosity_p=-1);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_spi_enable]: Enable the SPI";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }
    }
}

/**
* FPGA specifics: 
    Build the expected spi command
    Build the expected fpga register accesses
*/
function adc_write_command(addr_p, data_p) {

    //---------------------------------------------------------------------
    // write in the SPI_CONF0 register
    //---------------------------------------------------------------------
    const mode = 1; // 0: rd, 1: wr
    const spi_id = 1; // 0: cdce,1: adc, 2: dac, 3: amc
    const data = (spi_id << 4) + mode;
    addr = FPASIM_ADDR_WIREIN['SPI_CONF0'];
    sendToFPA_debugSetWireIn(addr, data);

    //---------------------------------------------------------------------
    // build the SPI commands
    //   (see the ads62p49 datasheet)
    //---------------------------------------------------------------------

    const spi_cmd = (addr_p << 8) + data_p;
    addr = FPASIM_ADDR_WIREIN['SPI_WR_DATA'];
    //---------------------------------------------------------------------
    // write in the SPI_WR_DATA register
    //---------------------------------------------------------------------
    sendToFPA_debugSetWireIn(addr, spi_cmd);

    //---------------------------------------------------------------------
    // write in the TRIG register
    //  => activate the spi_valid bit
    //---------------------------------------------------------------------
    addr = FPASIM_ADDR_TRIGIN['TRIG'];
    pos = FPASIM_POS_TRIGIN['spi_valid'];
    sendToFPA_debugSetTriggerIn(addr, pos);
    waitMs(100);

}

function adc_read_command(addr_p) {

    //---------------------------------------------------------------------
    // Enable the read on the spi device
    //---------------------------------------------------------------------
    const rst0 = 0; //  Software reset applied – resets all internal registers and self-clears to 0.
    const serial_out0 = 1; //0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).1:Serial readout enabled, Pin SDOUT functions as serial data readout.
    adc_set_config0(
        rst_p = rst0, serial_out_p = serial_out0,
        level_p = 0, mode_p = 0, verbosity_p = -1
    );

    //---------------------------------------------------------------------
    // write in the SPI_CONF0 register
    //---------------------------------------------------------------------
    const spi_mode = 0; // 0: rd, 1: wr
    const spi_id = 1; // 0: cdce,1: adc, 2: dac, 3: amc
    data = (spi_id << 4) + spi_mode;
    addr = FPASIM_ADDR_WIREIN['SPI_CONF0'];
    sendToFPA_debugSetWireIn(addr, data);

    //---------------------------------------------------------------------
    // build the SPI commands
    //   (see the ads62p49 datasheet)
    //---------------------------------------------------------------------
    data = 0x0;
    spi_cmd = (addr_p << 8) + data;
    //---------------------------------------------------------------------
    // write in the SPI_WR_DATA register
    //---------------------------------------------------------------------
    addr = FPASIM_ADDR_WIREIN['SPI_WR_DATA'];
    sendToFPA_debugSetWireIn(addr, spi_cmd);

    //---------------------------------------------------------------------
    // write in the TRIG register
    //  => activate the spi_valid bit
    //---------------------------------------------------------------------
    addr = FPASIM_ADDR_TRIGIN['TRIG'];
    pos = FPASIM_POS_TRIGIN['spi_valid'];
    sendToFPA_debugSetTriggerIn(addr, pos);

    // tempo
    waitMs(100);

    //---------------------------------------------------------------------
    // Read wire out registers
    //---------------------------------------------------------------------
    getLatestValue("FPA_WireOutValues");

    waitMs(600);
    //---------------------------------------------------------------------
    // Disable the read on the spi device
    //---------------------------------------------------------------------
    // tempo
    waitMs(500);
    const rst1 = 0; //  Software reset applied – resets all internal registers and self-clears to 0.
    const serial_out1 = 0; //0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).1:Serial readout enabled, Pin SDOUT functions as serial data readout.
    adc_set_config0(
        rst_p = rst1, serial_out_p = serial_out1,
        level_p = 0, mode_p = 0, verbosity_p = -1
    );


    return FPA_WireOutValues[21];

}

/**
 *  Set the register0
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [7]: rst
 *     1: Software reset applied – resets all internal registers and self-clears to 0.
 *     0: do nothing
 *  [0] : serial_out
 *     0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).
 *     1: Serial readout enabled, Pin SDOUT functions as serial data readout.
 */
function adc_set_config0(rst_p, serial_out_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = (rst_p << 7) + serial_out_p;
    const addr = ADC_ADDR['reg0'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config0]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "rst_p", bit_value_p = rst_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "serial_out_p", bit_value_p = serial_out_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }

}

/**
 *  Set the register1
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [2]: enable_low_speed
 *  0: LOW SPEED mode disabled. Use for sampling frequency > 80 MSPS
 *  1: Enable LOW SPEED mode for sampling frequencies ≤ 80 MSPS.
 *
 */
function adc_set_config1(enable_low_speed_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = (enable_low_speed_p << 2);
    addr = ADC_ADDR['reg1'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config1]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "enable_low_speed_p", bit_value_p = enable_low_speed_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }

}

/**
 *  Set the register2
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [6:5] ref: Internal or external reference selection
 *       00 : Internal reference enabled
 *       01:
 *       10:
 *       11: External reference enabled
 *  [1]: standby <STANDBY>
 *       0 Normal operation
 *       1 Both ADC channels are put in standby. Internal references, output buffers are active. This results in
 *    quick wake-up time from standby.
 */
function adc_set_config2(ref_p, standby_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = (ref_p << 5) + (standby_p << 1);
    addr = ADC_ADDR['reg2'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config2]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "ref_p", bit_value_p = ref_p, bit_width_p = 2, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "standby_p", bit_value_p = standby_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }

}


/**
 *  Set the register3
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [3:0]: power_down
 *    0000 Pins CTRL1, CTRL2, and CTRL3 determine power down modes.
 *    1000 Normal operation
 *    1001 Output buffer disabled for channel B
 *    1010 Output buffer disabled for channel A
 *    1011 Output buffer disabled for channel A and B
 *    1100 Global power down
 *    1101 Channel B standby
 *    1110 Channel A standby
 *    1111 Multiplexed mode, MUX- (only with CMOS interface)
 *       Channel A and B data is multiplexed and output on DA13 to DA0 pins. Refer to the Multiplexed
 *       Output Mode section in the APPLICATION INFORMATION for additional information.
 *
 */
function adc_set_config3(power_down_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = power_down_p;
    addr = ADC_ADDR['reg3'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config3]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "power_down_p", bit_value_p = power_down_p, bit_width_p = 4, level_p = level2, mode_p = mode_p);
        }
    }

}


/**
 *  Set the register4
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [7]: lvds_cmos
 *    0 Parallel CMOS interface
 *    1 DDR LVDS interface
 */
function adc_set_config4(lvds_cmos_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = (lvds_cmos_p << 7);
    addr = ADC_ADDR['reg4'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config4]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "lvds_cmos_p", bit_value_p = lvds_cmos_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 *  Set the register5
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  LVDS interface
 *     [7:5] clkout_pos_rise Output clock rising edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Falling edge shifted (delayed) by + (4/26)×Ts(1)
 *        110 Falling edge shifted (advanced) by – (7/26)×Ts
 *        111 Falling edge shifted (advanced) by – (4/26)×Ts
 *     [4:2] clkout_pos_fall Output clock falling edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Rising edge shifted (delayed) by + (4/26)×Ts
 *        110 Rising edge shifted (advanced) by – (7/26)×Ts
 *        111 Rising edge shifted (advanced) by – (4/26)×Ts
 *  CMOS interface
 *     [7:5]: clkout_pos_rise Output clock rising edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Rising edge shifted (delayed) by + (4/26)×Ts
 *        110 Rising edge shifted (advanced) by – (7/26)×Ts
 *        111 Rising edge shifted (advanced) by – (4/26)×Ts
 *     [4:2] clkout_pos_fall Output clock falling edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Falling edge shifted (delayed) by + (4/26)×Ts
 *        110 Falling edge shifted (advanced) by – (7/26)×Ts
 *        111 Falling edge shifted (advanced) by – (4/26)×Ts
 *  Note: 
 *        (1) Ts = 1 / sampling frequency
 *        (2) Keep the same duty cycle, move both edges by the same amount (i.e., write both D<4:2> and D<7:5> to be
 *        the same value).
 *
 */
function adc_set_config5(clkout_pos_rise_p, clkout_pos_fall_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = (clkout_pos_rise_p << 5) + clkout_pos_fall_p;
    addr = ADC_ADDR['reg5'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config5]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "clkout_pos_rise_p", bit_value_p = clkout_pos_rise_p, bit_width_p = 3, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "clkout_pos_fall_p", bit_value_p = clkout_pos_fall_p, bit_width_p = 3, level_p = level2, mode_p = mode_p);
        }
    }

}

/**
 *  Set the register6
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [6]: en_independant_chan_ctrl
 *     0 Common control – both channels use common control settings for test patterns, offset correction,
 *       fine gain, gain correction and SNR Boost functions. These settings can be specified in a single set of registers.
 *     1 Independent control – both channels can be programmed with independent control settings for test
 *       patterns, offset correction and SNR Boost functions. Separate registers are available for each channel.
 *  [2:1]: data_format
 *    10 2s complement
 *    11 Offset binary
 *
 */
function adc_set_config6(en_independant_chan_ctrl_p, data_format_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = (en_independant_chan_ctrl_p << 6) + (data_format_p << 1);
    addr = ADC_ADDR['reg6'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config6]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "en_independant_chan_ctrl_p", bit_value_p = en_independant_chan_ctrl_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "data_format_p", bit_value_p = data_format_p, bit_width_p = 2, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 *  Set the register7
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [7:0] custom_pattern_low
 *    8 lower bits of custom pattern available at the output instead of ADC data.
 *  Note: Use this mode along with “Test Patterns” (register 0x62).
 *
 */
function adc_set_config7(custom_patter_low_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = custom_patter_low_p;
    addr = ADC_ADDR['reg7'];
    adc_write_command(addr_p = 0x51, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config7]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "custom_patter_low_p", bit_value_p = custom_patter_low_p, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }

}

/**
 *  Set the register8
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [5:0] custom_pattern_high
 *    6 upper bits of custom pattern available at the output instead of ADC data
 *  Note: Use this mode along with “Test Patterns” (register 0x62).
 *
 */
function adc_set_config8(custom_patter_high_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = custom_patter_high_p;
    addr = ADC_ADDR['reg8'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config8]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "custom_patter_high_p", bit_value_p = custom_patter_high_p, bit_width_p = 6, level_p = level2, mode_p = mode_p);
        }
    }

}

/**
 *  Set the register9
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [6]:  en_offset_correction – Common/Ch A>
 *       Offset correction enable control for both channels (with common control) or for channel A only (with
 *       independent control).
 *    0 Offset correction disabled
 *    1 Offset correction enabled
 *
 */
function adc_set_config9(en_offset_correction_cha_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = (en_offset_correction_cha_p << 6);
    addr = ADC_ADDR['reg9'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config9]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "en_offset_correction_cha_p", bit_value_p = en_offset_correction_cha_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }
}
/**
 *  Set the register10
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [7:4] gain_common_or_cha <GAIN – Common/Ch A>
 *   Gain control for both channels (with common control) or for channel A only (with independent control).
 *     0000 0 dB gain, default after reset
 *     0001 0.5 dB gain
 *     0010 1.0 dB gain
 *     0011 1.5 dB gain
 *     0100 2.0 dB gain
 *     0101 2.5 dB gain
 *     0110 3.0 dB gain
 *     0111 3.5 dB gain
 *     1000 4.0 dB gain
 *     1001 4.5 dB gain
 *     1010 5.0 dB gain
 *     1011 5.5 dB gain
 *     1100 6.0 dB gain
 *  [3:0] offset_corr_time_common_or_cha <OFFSET CORR TIME CONSTANT – Common/Ch A>
 *     Correction loop time constant in number of clock cycles.
 *     Applies to both channels (with common control) or for channel A only (with independent control).
 *     0000 256 k
 *     0001 512 k
 *     0010 1 M
 *     0011 2 M
 *     0100 4 M
 *     0101 8 M
 *     0110 16 M
 *     0111 32 M
 *     1000 64 M
 *     1001 128 M
 *     1010 256 M
 *     1011 512 M
 *
 */
function adc_set_config10(gain_common_or_cha_p, offset_corr_time_common_or_cha_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = (gain_common_or_cha_p << 4) + offset_corr_time_common_or_cha_p;
    addr = ADC_ADDR['reg10'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config10]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "gain_common_or_cha_p", bit_value_p = gain_common_or_cha_p, bit_width_p = 4, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "offset_corr_time_common_or_cha_p", bit_value_p = offset_corr_time_common_or_cha_p, bit_width_p = 4, level_p = level2, mode_p = mode_p);
        }
    }

}
/**
 *  Set the register11
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 * [6:0] fine_gain_adjust_common_or_cha
 * Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
 * additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
 * trimmed channel gain is:
 *     Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
 * Note: that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
 *      <GAIN PROGRAMMABILITY>
 *
 */
function adc_set_config11(fine_gain_adjust_common_or_cha_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = (fine_gain_adjust_common_or_cha_p);
    addr = ADC_ADDR['reg11'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config11]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "fine_gain_adjust_common_or_cha_p", bit_value_p = fine_gain_adjust_common_or_cha_p, bit_width_p = 7, level_p = level2, mode_p = mode_p);
        }
    }

}
/**
 *  Set the register12
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 * [2:0] test_pattern_common_or_cha Test Patterns to verify data capture.
 *   Applies to both channels (with common control) or for channel A only (with independent control).
 *   000 Normal operation
 *   001 Outputs all zeros
 *   010 Outputs all ones
 *   011 Outputs toggle pattern – see Figure 14 and Figure 15 for test pattern timing diagrams for LVDS and CMOS modes.
 *       In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
 *       In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
 *   100 Outputs digital ramp
 *        In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
 *        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
 *   101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
 *   110 Unused
 *   111 Unused
 */
function adc_set_config12(test_pattern_common_or_cha_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = (test_pattern_common_or_cha_p);
    addr = ADC_ADDR['reg12'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config12]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "test_pattern_common_or_cha_p", bit_value_p = test_pattern_common_or_cha_p, bit_width_p = 3, level_p = level2, mode_p = mode_p);
        }
    }

}

/**
 *  Set the register13
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [5:0]: offset_pedestal_common_or_cha <OFFSET PEDESTAL – Common/Ch A>
 *        When the offset correction is enabled, the final converged value (after the offset is corrected) will
 *        be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
 *        added to the final converged value by programming these bits. So, the final converged value will
 *        be = ideal mid-code + PEDESTAL.
 *        See "Offset Correction" in application section.
 *        Applies to both channels (with common control) or for channel A only (with independent control).
 *     011111 PEDESTAL = 31 LSB
 *     011110 PEDESTAL = 30 LSB
 *     011101 PEDESTAL = 29 LSB
 *     ...
 *     000000 PEDESTAL = 0
 *     ...
 *     111111 PEDESTAL = –1 LSB
 *     111110 PEDESTAL = –2 LSB
 *     ...
 *     100000 PEDESTAL = –32 LSB
 */

function adc_set_config13(offset_pedestal_common_or_cha_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = (offset_pedestal_common_or_cha_p);
    addr = ADC_ADDR['reg13'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config13]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "offset_pedestal_common_or_cha_p", bit_value_p = offset_pedestal_common_or_cha_p, bit_width_p = 6, level_p = level2, mode_p = mode_p);
        }
    }


}

/**
 *  Set the register14
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [6] offset_corr_chb
 *      Offset correction enable control for channel B (only with independent control).
 *    0 offset correction disabled
 *    1 offset correction enabled
 */

function adc_set_config14(offset_corr_chb_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = (offset_corr_chb_p << 6);
    addr = ADC_ADDR['reg14'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config14]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "offset_corr_chb_p", bit_value_p = offset_corr_chb_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }


}
/**
 *  Set the register15
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [7:4] gain_chb Gain programmability to 0.5 dB steps.
 *        Applies to channel B (only with independent control).
 *     0000 0 dB gain, default after reset
 *     0001 0.5 dB gain
 *     0010 1.0 dB gain
 *     0011 1.5 dB gain
 *     0100 2.0 dB gain
 *     0101 2.5 dB gain
 *     0110 3.0 dB gain
 *     0111 3.5 dB gain
 *     1000 4.0 dB gain
 *     1001 4.5 dB gain
 *     1010 5.0 dB gain
 *     1011 5.5 dB gain
 *     1100 6.0 dB gain
 *  [3:0] offset_corr_time_chb Time constant of correction loop in number of clock cycles.
 *        Applies to channel B (only with independent control)
 *   0000 256 k
 *   0001 512 k
 *   0010 1 M
 *   0011 2 M
 *   0100 4 M
 *   0101 8 M
 *   0110 16 M
 *   0111 32 M
 *   1000 64 M
 *   1001 128 M
 *   1010 256 M
 *   1011 512 M
 *
 */
function adc_set_config15(gain_chb_p, offset_corr_time_chb_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = (gain_chb_p << 4) + offset_corr_time_chb_p;
    addr = ADC_ADDR['reg15'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config15]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "gain_chb_p", bit_value_p = gain_chb_p, bit_width_p = 4, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "offset_corr_time_chb_p", bit_value_p = offset_corr_time_chb_p, bit_width_p = 4, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 *  Set the register16
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 * [7:0] fine_gain_adjust_chb
 *     Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
 *     additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
 *     trimmed channel gain is:
 *        Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
 * Note that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
 *  <GAIN PROGRAMMABILITY>
 *
 */
function adc_set_config16(fine_gain_adjust_chb_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = fine_gain_adjust_chb_p;
    addr = ADC_ADDR['reg16'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config16]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "fine_gain_adjust_chb_p", bit_value_p = fine_gain_adjust_chb_p, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }
}
/**
 *  Set the register17
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [2:0]: test_pattern_chb Test Patterns to verify data capture.
 *        Applies to channel B (only with independent control)
 *      000 Normal operation
 *      001 Outputs all zeros
 *      010 Outputs all ones
 *      011 Outputs toggle pattern – see Figure 14 and Figure 15 for LVDS and CMOS modes.
 *         In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
 *         In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
 *      100 Outputs digital ramp
 *         In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
 *         In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
 *      101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
 *      110 Unused
 *      111 Unused
 */

function adc_set_config17(test_pattern_chb_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = test_pattern_chb_p;
    addr = ADC_ADDR['reg17'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config17]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "test_pattern_chb_p", bit_value_p = test_pattern_chb_p, bit_width_p = 3, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 *  Set the register18
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [5:0]: offset_pedestal_common_or_chb
 *        When the offset correction is enabled, the final converged value (after the offset is corrected) will
 *        be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
 *        added to the final converged value by programming these bits. So, the final converged value will
 *        be = ideal mid-code + PEDESTAL. See "Offset Correction" in application section.
 *        Applies to channel B (only with independent control).
 *    011111 PEDESTAL = 31 LSB
 *    011110 PEDESTAL = 30 LSB
 *    011101 PEDESTAL = 29 LSB
 *    ...
 *    000000 PEDESTAL = 0
 *    ...
 *    111111 PEDESTAL = –1 LSB
 *    111110 PEDESTAL = –2 LSB
 *    ...
 *    100000 PEDESTAL = –32 LSB
 */
function adc_set_config18(offset_pedestal_common_or_chb_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    data = offset_pedestal_common_or_chb_p;
    addr = ADC_ADDR['reg18'];
    adc_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_set_config18]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "offset_pedestal_common_or_chb_p", bit_value_p = offset_pedestal_common_or_chb_p, bit_width_p = 6, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 *  Get the register0
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [7]: rst
 *     1: Software reset applied – resets all internal registers and self-clears to 0.
 *     0: do nothing
 *  [0] : serial_out
 *     0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).
 *     1: Serial readout enabled, Pin SDOUT functions as serial data readout.
 */
function adc_get_config0(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg0'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config0]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "rst_p", bit_pos_p = 7, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "serial_out_p", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register1
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [2]: enable_low_speed
 *  0: LOW SPEED mode disabled. Use for sampling frequency > 80 MSPS
 *  1: Enable LOW SPEED mode for sampling frequencies ≤ 80 MSPS.
 *
 */
function adc_get_config1(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg1'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config1]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "enable_low_speed_p", bit_pos_p = 2, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}


/**
 *  Get the register2
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [6:5] ref: Internal or external reference selection
 *       00 : Internal reference enabled
 *       01:
 *       10:
 *       11: External reference enabled
 *  [1]: standby <STANDBY>
 *       0 Normal operation
 *       1 Both ADC channels are put in standby. Internal references, output buffers are active. This results in
 *    quick wake-up time from standby.
 *
 */
function adc_get_config2(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg2'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config2]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "ref_p", bit_pos_p = 5, bit_width_p = 2, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "standby_p", bit_pos_p = 1, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register3
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [3:0]: power_down
 *    0000 Pins CTRL1, CTRL2, and CTRL3 determine power down modes.
 *    1000 Normal operation
 *    1001 Output buffer disabled for channel B
 *    1010 Output buffer disabled for channel A
 *    1011 Output buffer disabled for channel A and B
 *    1100 Global power down
 *    1101 Channel B standby
 *    1110 Channel A standby
 *    1111 Multiplexed mode, MUX- (only with CMOS interface)
 *       Channel A and B data is multiplexed and output on DA13 to DA0 pins. Refer to the Multiplexed
 *       Output Mode section in the APPLICATION INFORMATION for additional information.
 *
 */
function adc_get_config3(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg3'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config3]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "power_down_p", bit_pos_p = 0, bit_width_p = 4, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register4
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [7]: lvds_cmos
 *    0 Parallel CMOS interface
 *    1 DDR LVDS interface
 */
function adc_get_config4(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg4'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config4]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "lvds_cmos", bit_pos_p = 7, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register5
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  LVDS interface
 *     [7:5] clkout_pos_rise Output clock rising edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Falling edge shifted (delayed) by + (4/26)×Ts(1)
 *        110 Falling edge shifted (advanced) by – (7/26)×Ts
 *        111 Falling edge shifted (advanced) by – (4/26)×Ts
 *     [4:2] clkout_pos_fall Output clock falling edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Rising edge shifted (delayed) by + (4/26)×Ts
 *        110 Rising edge shifted (advanced) by – (7/26)×Ts
 *        111 Rising edge shifted (advanced) by – (4/26)×Ts
 *  CMOS interface
 *     [7:5]: clkout_pos_rise Output clock rising edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Rising edge shifted (delayed) by + (4/26)×Ts
 *        110 Rising edge shifted (advanced) by – (7/26)×Ts
 *        111 Rising edge shifted (advanced) by – (4/26)×Ts
 *     [4:2] clkout_pos_fall Output clock falling edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Falling edge shifted (delayed) by + (4/26)×Ts
 *        110 Falling edge shifted (advanced) by – (7/26)×Ts
 *        111 Falling edge shifted (advanced) by – (4/26)×Ts
 *  Note: 
 *        (1) Ts = 1 / sampling frequency
 *        (2) Keep the same duty cycle, move both edges by the same amount (i.e., write both D<4:2> and D<7:5> to be
 *        the same value).
 */
function adc_get_config5(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg5'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config5]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "clkout_pos_rise_p", bit_pos_p = 5, bit_width_p = 3, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "clkout_pos_fall_p", bit_pos_p = 2, bit_width_p = 3, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}


/**
 *  Get the register6
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [6]: en_independant_chan_ctrl
 *     0 Common control – both channels use common control settings for test patterns, offset correction,
 *       fine gain, gain correction and SNR Boost functions. These settings can be specified in a single set of registers.
 *     1 Independent control – both channels can be programmed with independent control settings for test
 *       patterns, offset correction and SNR Boost functions. Separate registers are available for each channel.
 *  [2:1]: data_format
 *    10 2s complement
 *    11 Offset binary
 */
function adc_get_config6(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg6'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config6]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "en_independant_chan_ctrl_p", bit_pos_p = 6, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "data_format_p", bit_pos_p = 1, bit_width_p = 2, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register7
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [7:0] custom_pattern_low
 *    8 lower bits of custom pattern available at the output instead of ADC data.
 *  Note: Use this mode along with “Test Patterns” (register 0x62).
 *
 */
function adc_get_config7(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg7'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config7]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "custom_patter_low_p", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register8
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [5:0] custom_pattern_high
 *    6 upper bits of custom pattern available at the output instead of ADC data
 *  Note: Use this mode along with “Test Patterns” (register 0x62).
 *
 *
 */
function adc_get_config8(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg8'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config8]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "custom_patter_high_p", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register9
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [6]:  en_offset_correction – Common/Ch A>
 *       Offset correction enable control for both channels (with common control) or for channel A only (with
 *       independent control).
 *    0 Offset correction disabled
 *    1 Offset correction enabled
 *
 */
function adc_get_config9(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg9'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config9]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "en_offset_correction_cha_p", bit_pos_p = 6, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register10
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [7:4] gain_common_or_cha <GAIN – Common/Ch A>
 *   Gain control for both channels (with common control) or for channel A only (with independent control).
 *     0000 0 dB gain, default after reset
 *     0001 0.5 dB gain
 *     0010 1.0 dB gain
 *     0011 1.5 dB gain
 *     0100 2.0 dB gain
 *     0101 2.5 dB gain
 *     0110 3.0 dB gain
 *     0111 3.5 dB gain
 *     1000 4.0 dB gain
 *     1001 4.5 dB gain
 *     1010 5.0 dB gain
 *     1011 5.5 dB gain
 *     1100 6.0 dB gain
 *  [3:0] offset_corr_time_common_or_cha <OFFSET CORR TIME CONSTANT – Common/Ch A>
 *     Correction loop time constant in number of clock cycles.
 *     Applies to both channels (with common control) or for channel A only (with independent control).
 *     0000 256 k
 *     0001 512 k
 *     0010 1 M
 *     0011 2 M
 *     0100 4 M
 *     0101 8 M
 *     0110 16 M
 *     0111 32 M
 *     1000 64 M
 *     1001 128 M
 *     1010 256 M
 *     1011 512 M
 *
 */
function adc_get_config10(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg10'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config10]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "gain_common_or_cha_p", bit_pos_p = 4, bit_width_p = 4, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "offset_corr_time_common_or_cha_p", bit_pos_p = 0, bit_width_p = 4, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register11
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 * [6:0] fine_gain_adjust_common_or_cha
 * Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
 * additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
 * trimmed channel gain is:
 *     Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
 * Note: that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
 *      <GAIN PROGRAMMABILITY>
 *
 */
function adc_get_config11(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg11'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config11]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "fine_gain_adjust_common_or_cha_p", bit_pos_p = 0, bit_width_p = 7, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register12
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 * [2:0] test_pattern_common_or_cha Test Patterns to verify data capture.
 *   Applies to both channels (with common control) or for channel A only (with independent control).
 *   000 Normal operation
 *   001 Outputs all zeros
 *   010 Outputs all ones
 *   011 Outputs toggle pattern – see Figure 14 and Figure 15 for test pattern timing diagrams for LVDS and CMOS modes.
 *       In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
 *       In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
 *   100 Outputs digital ramp
 *        In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
 *        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
 *   101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
 *   110 Unused
 *   111 Unused
 *
 */
function adc_get_config12(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg12'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config12]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "test_pattern_common_or_cha_p", bit_pos_p = 0, bit_width_p = 3, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register13
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [5:0]: offset_pedestal_common_or_cha <OFFSET PEDESTAL – Common/Ch A>
 *        When the offset correction is enabled, the final converged value (after the offset is corrected) will
 *        be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
 *        added to the final converged value by programming these bits. So, the final converged value will
 *        be = ideal mid-code + PEDESTAL.
 *        See "Offset Correction" in application section.
 *        Applies to both channels (with common control) or for channel A only (with independent control).
 *     011111 PEDESTAL = 31 LSB
 *     011110 PEDESTAL = 30 LSB
 *     011101 PEDESTAL = 29 LSB
 *     ...
 *     000000 PEDESTAL = 0
 *     ...
 *     111111 PEDESTAL = –1 LSB
 *     111110 PEDESTAL = –2 LSB
 *     ...
 *     100000 PEDESTAL = –32 LSB
 *
 */
function adc_get_config13(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg13'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config13]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "offset_pedestal_common_or_cha_p", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register14
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [6] offset_corr_chb
 *      Offset correction enable control for channel B (only with independent control).
 *    0 offset correction disabled
 *    1 offset correction enabled
 *
 */
function adc_get_config14(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg14'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config14]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "offset_corr_chb", bit_pos_p = 6, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register15
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [7:4] gain_chb Gain programmability to 0.5 dB steps.
 *        Applies to channel B (only with independent control).
 *     0000 0 dB gain, default after reset
 *     0001 0.5 dB gain
 *     0010 1.0 dB gain
 *     0011 1.5 dB gain
 *     0100 2.0 dB gain
 *     0101 2.5 dB gain
 *     0110 3.0 dB gain
 *     0111 3.5 dB gain
 *     1000 4.0 dB gain
 *     1001 4.5 dB gain
 *     1010 5.0 dB gain
 *     1011 5.5 dB gain
 *     1100 6.0 dB gain
 *  [3:0] offset_corr_time_chb Time constant of correction loop in number of clock cycles.
 *        Applies to channel B (only with independent control)
 *   0000 256 k
 *   0001 512 k
 *   0010 1 M
 *   0011 2 M
 *   0100 4 M
 *   0101 8 M
 *   0110 16 M
 *   0111 32 M
 *   1000 64 M
 *   1001 128 M
 *   1010 256 M
 *   1011 512 M
 */
function adc_get_config15(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg15'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config15]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "gain_chb_p", bit_pos_p = 4, bit_width_p = 4, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "offset_corr_time_chb_p", bit_pos_p = 4, bit_width_p = 4, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register16
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 * [7:0] fine_gain_adjust_chb
 *     Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
 *     additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
 *     trimmed channel gain is:
 *        Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
 * Note that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
 *  <GAIN PROGRAMMABILITY>
 *
 */
function adc_get_config16(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg16'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config16]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "fine_gain_adjust_chb_p", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register17
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [2:0]: test_pattern_chb Test Patterns to verify data capture.
 *        Applies to channel B (only with independent control)
 *      000 Normal operation
 *      001 Outputs all zeros
 *      010 Outputs all ones
 *      011 Outputs toggle pattern – see Figure 14 and Figure 15 for LVDS and CMOS modes.
 *         In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
 *         In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
 *      100 Outputs digital ramp
 *         In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
 *         In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
 *      101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
 *      110 Unused
 *      111 Unused
 *
 */
function adc_get_config17(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg17'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config17]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "test_pattern_chb_p", bit_pos_p = 0, bit_width_p = 3, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 *  Get the register18
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 *  [5:0]: offset_pedestal_common_or_chb
 *        When the offset correction is enabled, the final converged value (after the offset is corrected) will
 *        be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
 *        added to the final converged value by programming these bits. So, the final converged value will
 *        be = ideal mid-code + PEDESTAL. See "Offset Correction" in application section.
 *        Applies to channel B (only with independent control).
 *    011111 PEDESTAL = 31 LSB
 *    011110 PEDESTAL = 30 LSB
 *    011101 PEDESTAL = 29 LSB
 *    ...
 *    000000 PEDESTAL = 0
 *    ...
 *    111111 PEDESTAL = –1 LSB
 *    111110 PEDESTAL = –2 LSB
 *    ...
 *    100000 PEDESTAL = –32 LSB
 *
 */
function adc_get_config18(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = ADC_ADDR['reg18'];
    data = adc_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            msg = "[adc_get_config18]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "offset_pedestal_common_or_chb_p", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;

}


function adc_get_config(reg_id) {

    if (reg_id == 7) {
        addr = 0x51
        value = adc_read_command(addr_p = addr);
        print('custom_patter_low_p: 0x', value.toString(16))
    }

}

function adc_generate_pattern0(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;

    /*
    //###############################################################
    // register6
    //###############################################################
    // [6]: en_independant_chan_ctrl
    //    0 Common control – both channels use common control settings for test patterns, offset correction,
    //      fine gain, gain correction and SNR Boost functions. These settings can be specified in a single set of registers.
    //    1 Independent control – both channels can be programmed with independent control settings for test
    //      patterns, offset correction and SNR Boost functions. Separate registers are available for each channel.
    // [2:1]: data_format
    //   10 2s complement
    //   11 Offset binary
    */
    en_independant_chan_ctrl = 1;
    data_format = parseInt('10', 2);

    adc_set_config6(
        en_independant_chan_ctrl_p = en_independant_chan_ctrl, data_format_p = data_format,
        level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p
    );

    //###############################################################
    // register12
    //###############################################################
    // [2:0] test_pattern_common_or_cha Test Patterns to verify data capture.
    //   Applies to both channels (with common control) or for channel A only (with independent control).
    //   000 Normal operation
    //   001 Outputs all zeros
    //   010 Outputs all ones
    //   011 Outputs toggle pattern – see Figure 14 and Figure 15 for test pattern timing diagrams for LVDS and CMOS modes.
    //       In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
    //       In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
    //   100 Outputs digital ramp
    //        In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
    //        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
    //   101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
    //   110 Unused
    //   111 Unused
    test_pattern_common_or_cha = parseInt('011', 2);
    adc_set_config12(
        test_pattern_common_or_cha_p = test_pattern_common_or_cha,
        level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p
    );

    //###############################################################
    // register17
    //###############################################################
    // [2:0]: test_pattern_chb Test Patterns to verify data capture.
    //       Applies to channel B (only with independent control)
    //     000 Normal operation
    //     001 Outputs all zeros
    //     010 Outputs all ones
    //     011 Outputs toggle pattern – see Figure 14 and Figure 15 for LVDS and CMOS modes.
    //        In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
    //        In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
    //     100 Outputs digital ramp
    //        In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
    //        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
    //     101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
    //     110 Unused
    //     111 Unused
    test_pattern_chb = parseInt('100', 2);

    adc_set_config17(
        test_pattern_chb_p = test_pattern_chb,
        level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p
    );


}

function adc_display_all_config(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;

    adc_get_config0(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config1(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config2(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config3(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config4(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config5(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config6(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config7(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config8(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config9(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config10(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config11(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config12(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config13(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config14(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config15(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config16(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config17(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    adc_get_config18(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);


}




/**
 *  Configure the ads62p49 (adc) Device
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 *
 */
function ADS62P49_configure(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    msg = "ADS62P49_configure";
    display_title(msg_p = msg, level_p = level0, mode_p = mode_p);

    // Enable the SPI on the FPGA board
    adc_spi_enable(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
    /*
    //###############################################################
    // register0
    //###############################################################
    // [7]: rst
    //    1: Software reset applied – resets all internal registers and self-clears to 0.
    //    0: do nothing
    // [0] : serial_out
    //    0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).
    //    1: Serial readout enabled, Pin SDOUT functions as serial data readout.
    */
    rst = 1; //  Software reset applied – resets all internal registers and self-clears to 0.
    serial_out = 0; //0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).1:Serial readout enabled, Pin SDOUT functions as serial data readout.
    adc_set_config0(
        rst_p = rst, serial_out_p = serial_out,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    /*
    //###############################################################
    // register1
    //###############################################################
    // [2]: enable_low_speed
    //      0: LOW SPEED mode disabled. Use for sampling frequency > 80 MSPS
    //      1: Enable LOW SPEED mode for sampling frequencies ≤ 80 MSPS.
    */
    enable_low_speed = 0;
    adc_set_config1(
        enable_low_speed_p = enable_low_speed,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );


    /*
    //###############################################################
    // register2
    //###############################################################
    // [6] ref: Internal or external reference selection
    //      00 : Internal reference enabled
    //      01:
    //      10:
    //      11: External reference enabled
    // [1]: standby <STANDBY>
    //      0 Normal operation
    //      1 Both ADC channels are put in standby. Internal references, output buffers are active. This results in
    //   quick wake-up time from standby.
    */
    ref = parseInt('00', 2);
    standby = 0;
    adc_set_config2(
        ref_p = ref, standby_p = standby,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    /*
    //###############################################################
    // register3
    //###############################################################
    // [3:0]: power_down
    //   0000 Pins CTRL1, CTRL2, and CTRL3 determine power down modes.
    //   1000 Normal operation
    //   1001 Output buffer disabled for channel B
    //   1010 Output buffer disabled for channel A
    //   1011 Output buffer disabled for channel A and B
    //   1100 Global power down
    //   1101 Channel B standby
    //   1110 Channel A standby
    //   1111 Multiplexed mode, MUX- (only with CMOS interface)
    //      Channel A and B data is multiplexed and output on DA13 to DA0 pins. Refer to the Multiplexed
    //      Output Mode section in the APPLICATION INFORMATION for additional information.
    */
    power_down = parseInt('1000', 2);
    adc_set_config3(
        power_down_p = power_down,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    /*
    //###############################################################
    // register4
    //###############################################################
    // [7]: lvds_cmos
    //   0 Parallel CMOS interface
    //   1 DDR LVDS interface
    */
    lvds_cmos = 1;
    adc_set_config4(
        lvds_cmos_p = lvds_cmos,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    /*
    //###############################################################
    // register5
    //###############################################################
    // LVDS interface
    //    [7:5] clkout_pos_rise Output clock rising edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Falling edge shifted (delayed) by + (4/26)×Ts(1)
    //       110 Falling edge shifted (advanced) by – (7/26)×Ts
    //       111 Falling edge shifted (advanced) by – (4/26)×Ts
    //    [4:2] clkout_pos_fall Output clock falling edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Rising edge shifted (delayed) by + (4/26)×Ts
    //       110 Rising edge shifted (advanced) by – (7/26)×Ts
    //       111 Rising edge shifted (advanced) by – (4/26)×Ts
    // CMOS interface
    //    [7:5]: clkout_pos_rise Output clock rising edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Rising edge shifted (delayed) by + (4/26)×Ts
    //       110 Rising edge shifted (advanced) by – (7/26)×Ts
    //       111 Rising edge shifted (advanced) by – (4/26)×Ts
    //    [4:2] clkout_pos_fall Output clock falling edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Falling edge shifted (delayed) by + (4/26)×Ts
    //       110 Falling edge shifted (advanced) by – (7/26)×Ts
    //       111 Falling edge shifted (advanced) by – (4/26)×Ts
    // Note: 
    //       (1) Ts = 1 / sampling frequency
    //       (2) Keep the same duty cycle, move both edges by the same amount (i.e., write both D<4:2> and D<7:5> to be
    //       the same value).
    */
    clkout_pos_rise = parseInt('000', 2);
    clkout_pos_fall = parseInt('000', 2);

    adc_set_config5(
        clkout_pos_rise_p = clkout_pos_rise, clkout_pos_fall_p = clkout_pos_fall,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    /*
    //###############################################################
    // register6
    //###############################################################
    // [6]: en_independant_chan_ctrl
    //    0 Common control – both channels use common control settings for test patterns, offset correction,
    //      fine gain, gain correction and SNR Boost functions. These settings can be specified in a single set of registers.
    //    1 Independent control – both channels can be programmed with independent control settings for test
    //      patterns, offset correction and SNR Boost functions. Separate registers are available for each channel.
    // [2:1]: data_format
    //   10 2s complement
    //   11 Offset binary
    */
    en_independant_chan_ctrl = 1;
    data_format = parseInt('10', 2);

    adc_set_config6(
        en_independant_chan_ctrl_p = en_independant_chan_ctrl, data_format_p = data_format,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    /*
    //###############################################################
    // register7
    //###############################################################
    // [7:0] custom_pattern_low
    //   8 lower bits of custom pattern available at the output instead of ADC data.
    // Note: Use this mode along with “Test Patterns” (register 0x62).
    */
    custom_patter_low = parseInt('10011111', 2);

    adc_set_config7(
        custom_patter_low_p = custom_patter_low,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    /*
    //###############################################################
    // register8
    //###############################################################
    // [5:0] custom_pattern_high
    //   6 upper bits of custom pattern available at the output instead of ADC data
    // Note: Use this mode along with “Test Patterns” (register 0x62).
    */
    custom_patter_high = parseInt('100000', 2);

    adc_set_config8(
        custom_patter_high_p = custom_patter_high,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    /*
    //###############################################################
    // register9
    //###############################################################
    // [6]:  en_offset_correction – Common/Ch A>
    //      Offset correction enable control for both channels (with common control) or for channel A only (with
    //      independent control).
    //   0 Offset correction disabled
    //   1 Offset correction enabled
    */
    en_offset_correction_cha = 0;

    adc_set_config9(
        en_offset_correction_cha_p = en_offset_correction_cha,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    /*
    //###############################################################
    // register10
    //###############################################################
    // [7:4] gain_common_or_cha <GAIN – Common/Ch A>
    //  Gain control for both channels (with common control) or for channel A only (with independent control).
    //    0000 0 dB gain, default after reset
    //    0001 0.5 dB gain
    //    0010 1.0 dB gain
    //    0011 1.5 dB gain
    //    0100 2.0 dB gain
    //    0101 2.5 dB gain
    //    0110 3.0 dB gain
    //    0111 3.5 dB gain
    //    1000 4.0 dB gain
    //    1001 4.5 dB gain
    //    1010 5.0 dB gain
    //    1011 5.5 dB gain
    //    1100 6.0 dB gain
    // [3:0] offset_corr_time_common_or_cha <OFFSET CORR TIME CONSTANT – Common/Ch A>
    //    Correction loop time constant in number of clock cycles.
    //    Applies to both channels (with common control) or for channel A only (with independent control).
    //    0000 256 k
    //    0001 512 k
    //    0010 1 M
    //    0011 2 M
    //    0100 4 M
    //    0101 8 M
    //    0110 16 M
    //    0111 32 M
    //    1000 64 M
    //    1001 128 M
    //    1010 256 M
    //    1011 512 M
    */
    gain_cha = parseInt('0000', 2);
    offset_corr_time_cha = parseInt('0000', 2);

    adc_set_config10(
        gain_common_or_cha_p = gain_cha, offset_corr_time_common_or_cha_p = offset_corr_time_cha,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    //###############################################################
    // register11
    //###############################################################
    // [6:0] fine_gain_adjust_common_or_cha
    // Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
    // additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
    // trimmed channel gain is:
    //     Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
    // Note: that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
    //      <GAIN PROGRAMMABILITY>
    fine_gain_adjust_common_or_cha = parseInt('0000000', 2);

    adc_set_config11(
        fine_gain_adjust_common_or_cha_p = fine_gain_adjust_common_or_cha,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    //###############################################################
    // register12
    //###############################################################
    // [2:0] test_pattern_common_or_cha Test Patterns to verify data capture.
    //   Applies to both channels (with common control) or for channel A only (with independent control).
    //   000 Normal operation
    //   001 Outputs all zeros
    //   010 Outputs all ones
    //   011 Outputs toggle pattern – see Figure 14 and Figure 15 for test pattern timing diagrams for LVDS and CMOS modes.
    //       In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
    //       In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
    //   100 Outputs digital ramp
    //        In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
    //        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
    //   101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
    //   110 Unused
    //   111 Unused
    test_pattern_common_or_cha = parseInt('000', 2);
    adc_set_config12(
        test_pattern_common_or_cha_p = test_pattern_common_or_cha,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    //###############################################################
    // register13
    //###############################################################
    // [5:0]: offset_pedestal_common_or_cha <OFFSET PEDESTAL – Common/Ch A>
    //       When the offset correction is enabled, the final converged value (after the offset is corrected) will
    //       be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
    //       added to the final converged value by programming these bits. So, the final converged value will
    //       be = ideal mid-code + PEDESTAL.
    //       See "Offset Correction" in application section.
    //       Applies to both channels (with common control) or for channel A only (with independent control).
    //    011111 PEDESTAL = 31 LSB
    //    011110 PEDESTAL = 30 LSB
    //    011101 PEDESTAL = 29 LSB
    //    ...
    //    000000 PEDESTAL = 0
    //    ...
    //    111111 PEDESTAL = –1 LSB
    //    111110 PEDESTAL = –2 LSB
    //    ...
    //    100000 PEDESTAL = –32 LSB
    offset_pedestal_common_or_cha = parseInt('000000', 2);

    adc_set_config13(
        offset_pedestal_common_or_cha_p = offset_pedestal_common_or_cha,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    //###############################################################
    // register14
    //###############################################################
    // [6] offset_corr_chb
    //     Offset correction enable control for channel B (only with independent control).
    //   0 offset correction disabled
    //   1 offset correction enabled
    offset_corr_chb = 0;

    adc_set_config14(
        offset_corr_chb_p = offset_corr_chb,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    //###############################################################
    // register15
    //###############################################################
    // [7:4] gain_chb Gain programmability to 0.5 dB steps.
    //       Applies to channel B (only with independent control).
    //    0000 0 dB gain, default after reset
    //    0001 0.5 dB gain
    //    0010 1.0 dB gain
    //    0011 1.5 dB gain
    //    0100 2.0 dB gain
    //    0101 2.5 dB gain
    //    0110 3.0 dB gain
    //    0111 3.5 dB gain
    //    1000 4.0 dB gain
    //    1001 4.5 dB gain
    //    1010 5.0 dB gain
    //    1011 5.5 dB gain
    //    1100 6.0 dB gain
    // [3:0] offset_corr_time_chb Time constant of correction loop in number of clock cycles.
    //       Applies to channel B (only with independent control)
    //  0000 256 k
    //  0001 512 k
    //  0010 1 M
    //  0011 2 M
    //  0100 4 M
    //  0101 8 M
    //  0110 16 M
    //  0111 32 M
    //  1000 64 M
    //  1001 128 M
    //  1010 256 M
    //  1011 512 M
    gain_chb = parseInt('0000', 2);
    offset_corr_time_chb = parseInt('0000', 2);

    adc_set_config15(
        gain_chb_p = gain_chb, offset_corr_time_chb_p = offset_corr_time_chb,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    //###############################################################
    // register16
    //###############################################################
    // [7:0] fine_gain_adjust_chb
    //     Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
    //     additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
    //     trimmed channel gain is:
    //        Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
    // Note that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
    //  <GAIN PROGRAMMABILITY>
    fine_gain_adjust_chb = parseInt('0000000', 2);

    adc_set_config16(
        fine_gain_adjust_chb_p = fine_gain_adjust_chb,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    //###############################################################
    // register17
    //###############################################################
    // [2:0]: test_pattern_chb Test Patterns to verify data capture.
    //       Applies to channel B (only with independent control)
    //     000 Normal operation
    //     001 Outputs all zeros
    //     010 Outputs all ones
    //     011 Outputs toggle pattern – see Figure 14 and Figure 15 for LVDS and CMOS modes.
    //        In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
    //        In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
    //     100 Outputs digital ramp
    //        In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
    //        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
    //     101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
    //     110 Unused
    //     111 Unused
    test_pattern_chb = parseInt('000', 2);

    adc_set_config17(
        test_pattern_chb_p = test_pattern_chb,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    //###############################################################
    // register18
    //###############################################################
    // [5:0]: offset_pedestal_common_or_chb
    //       When the offset correction is enabled, the final converged value (after the offset is corrected) will
    //       be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
    //       added to the final converged value by programming these bits. So, the final converged value will
    //       be = ideal mid-code + PEDESTAL. See "Offset Correction" in application section.
    //       Applies to channel B (only with independent control).
    //   011111 PEDESTAL = 31 LSB
    //   011110 PEDESTAL = 30 LSB
    //   011101 PEDESTAL = 29 LSB
    //   ...
    //   000000 PEDESTAL = 0
    //   ...
    //   111111 PEDESTAL = –1 LSB
    //   111110 PEDESTAL = –2 LSB
    //   ...
    //   100000 PEDESTAL = –32 LSB
    offset_pedestal_common_or_chb = parseInt('000000', 0);

    adc_set_config18(
        offset_pedestal_common_or_chb_p = offset_pedestal_common_or_chb,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );





}